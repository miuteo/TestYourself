VARIANT$IS_CORECT$CONTENT$QUESTION_ID
A$1$Success$101
B$0$Failure$101
C$0$The hashCode() method fails to compile.$101
D$0$The equals() method fails to compile.$101
E$0$Another line of code fails to compile.$101
F$0$A runtime exception is thrown.$101
A$0$If equals(null) is called, the method should throw an exception.$115
B$1$If equals(null) is called, the method should return false.$115
C$0$If equals(null) is called, the method should return true.$115
D$0$If equals() is passed the wrong type, the method should throw an exception.$115
E$1$If equals() is passed the wrong type, the method should return false.$115
F$0$If equals() is passed the wrong type, the method should return true.$115
A$1$A reference to an object may be cast to a subclass of the object without an explicit cast.$215
B$1$If a method takes a class that is the superclass of three different object references, then any of those objects may be passed as a parameter to the method.$215
C$1$A reference to an object may be cast to a superclass of the object without an explicit cast.$215
D$0$All cast exceptions can be detected at compile time.$215
E$0$By defining a public instance method in the superclass, you guarantee that the specific method will be called in the parent class at runtime.$215
A$0$0$315
B$0$1$315
C$0$2$315
D$1$The result is undefined.$315
E$0$The code does not compile$315
F$0$A runtime exception is thrown$315
A$0$Map&lt;boolean, List&lt;String&gt;&gt;$415
B$0$Map&lt;Boolean, Map&lt;String&gt;&gt;$415
C$0$Map&lt;Long, TreeSet&lt;String&gt;&gt;$415
D$1$Map&lt;Boolean, List&lt;String&gt;&gt;$415
E$1$Map&lt;Boolean, Set&lt;String&gt;&gt;$415
F$0$None of the above$415
A$0$One$615
B$1$Two$615
C$0$Three$615
D$0$Four$615
E$1$Five$615
F$0$Six$615
A$0$a -&gt; {return 10;}$715
B$0$() -&gt; {String s = &quot;&quot;;}$715
C$1$() -&gt; 5$715
D$0$() -&gt; {return null}$715
E$1$() -&gt; &quot;The&quot; + &quot;Zoo&quot;$715
F$0$(int count) -&gt; count+1$715
G$1$() -&gt; {System.out.println(&quot;Giraffe&quot;); return 10;}$715
A$0$Inner in = new Inner();$116
B$0$Inner in = Outer.new Inner();$116
C$0$Outer.Inner in = new Outer.Inner();$116
D$0$Outer.Inner in = new Outer().Inner();$116
E$1$Outer.Inner in = new Outer().new Inner();$116
F$0$Outer.Inner in = Outer.new Inner();$116
A$0$It compiles and runs without issue.$216
B$0$The code will not compile because of line 2.$216
C$0$The code will not compile because of line 3.$216
D$0$The code will not compile because of line 4.$216
E$0$The code will not compile because of lines 2 and 3.$216
F$1$The code will not compile because of lines 3 and 4.$216
A$1$Comparable is in the java.util package.$316
B$1$Comparator is in the java.util package.$316
C$0$compare() is in the Comparable interface.$316
D$1$compare() is in the Comparator interface.$316
E$0$compare() takes one method parameter.$316
F$1$compare() takes two method parameters.$316
A$0${} {}$416
B$0${} {false=[], true=[]}$416
C$1${false=[], true=[]} {}$416
D$0${false=[], true=[]} {false=[], true=[]}$416
E$0$The code does not compile.$416
F$0$An exception is thrown.$416
A$0$TWF$616
B$0$TWDF$616
C$1$TWDEF$616
D$0$TWF followed by an exception$616
E$0$TWDF followed by an exception$616
F$0$TWEF followed by an exception$616
G$0$The code does not compile.$616
A$0$It compiles and outputs the two numbers, followed by Printed.$716
B$0$The code will not compile because of line b1.$716
C$0$The code will not compile because of line b2.$716
D$0$The code will not compile because of line b3.$716
E$0$The code will not compile because of line b4.$716
F$1$It compiles but the output cannot be determined ahead of time.$716
G$0$It compiles but throws an exception at runtime.$716
H$1$It compiles but waits forever at runtime.$716
A$0$Compiler error on line 2.$117
B$1$Compiler error on line 3.$117
C$1$Compiler error on line 5.$117
D$0$Compiler error on line 8.$117
E$0$Compiler error on line 12.$117
F$0$Compiler error on another line.$117
G$0$The code compiles successfully.$117
A$0$All instance variables are marked final.$217
B$1$boolean instance variables are accessed with is or get.$217
C$1$All instance variables are marked private.$217
D$0$They implement the JavaBean interface.$217
E$0$Variables are created using lazy instantiation.$217
F$1$The first letter of the any getter/setter, after the get, set, or is prefix, must be uppercase.$217
A$0$On line 1, fill in with &lt;&gt;.$317
B$1$On line 1, fill in with &lt;T&gt;.$317
C$0$On line 1, fill in with &lt;?&gt;.$317
D$1$On line 3, fill in with &lt;&gt;.$317
E$0$On line 3, fill in with &lt;T&gt;.$317
F$0$On line 3, fill in with &lt;?&gt;.$317
A$0$BiFunction&lt;Integer&gt; f = x -&gt; x*x;$417
B$0$BiFunction&lt;Integer, Integer&gt; f = x -&gt; x*x;$417
C$0$BinaryOperator&lt;Integer, Integer&gt; f = x -&gt; x*x;$417
D$0$Function&lt;Integer&gt; f = x -&gt; x*x;$417
E$1$Function&lt;Integer, Integer&gt; f = x -&gt; x*x;$417
F$0$None of the above$417
A$1$AutoCloseable$617
B$1$Closeable$617
C$0$Exception$617
D$0$RuntimeException$617
E$0$Serializable$617
A$0$It outputs 100 99.$717
B$1$It outputs 100 100.$717
C$0$The output cannot be determined ahead of time.$717
D$0$The code will not compile because of line w1.$717
E$0$The code will not compile because of line w2.$717
F$0$The code will not compile because of line w3.$717
G$0$The code will not compile because of line w2.$717
A$0$fish$118
B$0$FISH$118
C$0$0$118
D$0$1$118
E$0$false$118
F$0$true$118
G$1$The code does not compiles.$118
A$1$Inheritance supports access to protected variables.$218
B$1$Object composition tends to promote greater code reuse than inheritance.$218
C$0$Inheritance relies on the has-a principle.$218
D$0$Object composition supports method overriding at runtime.$218
E$1$Object composition requires a class variable to be declared public or accessible from a public method to be used by a class in a different package.$218
F$0$Object composition is always preferred to inheritance.$218
A$1$A a1 = new A();$318
B$1$A a2 = new B();$318
C$1$A a3 = new C();$318
D$0$C c1 = new A();$318
E$0$C c2 = new B();$318
F$0$C c1 = new C();$318
A$0$1$418
B$0$2$418
C$0$2.4$418
D$1$1.2 and 2.4$418
E$0$There is no output$418
F$0$The code does not compile$418
G$0$An exception is thrown$418
A$0$Exception, AutoCloseable$618
B$1$Exception, Closeable$618
C$0$IllegalStateException, AutoCloseable$618
D$0$IllegalStateException, Closeable$618
E$0$IOException, AutoCloseable$618
F$0$IOException, Closeable$618
A$0$It outputs Stock Room Full!$718
B$0$The code will not compile because of line j1.$718
C$0$The code will not compile because of line j2.$718
D$0$The code will not compile because of line j3.$718
E$0$It compiles but throws an exception at runtime.$718
F$1$It compiles but waits forever at runtime.$718
A$1$public void toddle() {}$119
B$0$public void Toddle() {}$119
C$1$public final void toddle() {}$119
D$0$public static void toddle() {}$119
E$0$public void toddle() throws Exception {}$119
F$0$public void toddle(boolean fall) {}$119
A$0$Create read-only objects that are thread-safe.$219
B$1$Manage a reusable cache of objects.$219
C$0$Ensure that all objects are lazily instantiated.$219
D$1$Manage write access to a log file.$219
E$1$Provide central access to application configuration data.$219
F$0$Allow multiple instances of a static object to be managed in memory.$219
A$1$If we fill in the blank with List, the output is [10].$319
B$0$If we fill in the blank with List, the output is [10, 12].$319
C$0$If we fill in the blank with Queue, the output is [10].$319
D$1$If we fill in the blank with Queue, the output is [10, 12].$319
E$0$The code does not compile in either scenario.$319
F$0$A runtime exception is thrown.$319
A$1$BooleanSupplier$419
B$0$CharSupplier$419
C$1$DoubleSupplier$419
D$0$FloatSupplier$419
E$1$IntSupplier$419
F$0$StringSupplier$419
A$0$Exception$619
B$0$RuntimeException$619
C$0$SQLException$619
D$1$SQLException | IOException$619
E$0$SQLException | RuntimeException$619
A$1$It compiles without issue.$719
B$0$The code will not compile because of line k2.$719
C$0$The code will not compile because of line k3.$719
D$0$The lock locks acquired on k1 and k4 are on the same object.$719
E$0$The class correctly prevents concurrency issues for the value of tickets when accessed by multiple threads.$719
F$1$At most one instance of TicketManager will be created in the application.$719
A$0$toddle,toddle,$120
B$0$toddle,walk,$120
C$1$walk,toddle,$120
D$0$walk,walk,$120
E$0$The code does not compile.$120
F$0$A runtime exception is thrown.$120
G$0$$120
H$0$$120
A$1$It compiles without issue.$220
B$0$The code will not compile because of line 2.$220
C$0$The code will not compile because of line 4.$220
D$0$The code will not compile because of line 5.$220
E$0$The code will not compile because of lines 2 and 5.$220
F$0$The code will not compile because the class Falcon doesn&#x2019;t implement the interface methods.$220
A$0$false$320
B$0$true$320
C$0$Compiler error on line 4.$320
D$0$Compiler error on line 5.$320
E$1$Compiler error on line 7.$320
F$0$A runtime exception is thrown.$320
A$0$IntStream.range(1, 6);$420
B$1$IntStream.range(1, 6).forEach(System.out::println);$420
C$0$IntStream.range(1, 6).mapToObj(1 -&gt; i).forEach(System.out::println);$420
D$0$None of the above is equivalent.$420
E$0$The provided code does not compile.$420
A$0$One or more constructors must be coded.$620
B$0$Only checked exceptions may be created.$620
C$0$Only unchecked exceptions may be created.$620
D$0$The toString() method must be coded.$620
E$1$None of the above.$620
A$1$By itself, concurrency does not guarantee which task will be completed first.$720
B$0$Concurrency always improves the performance of an application.$720
C$0$Computers with a single processor do not benefit from concurrency.$720
D$1$Applications with many resource-heavy tasks tend to benefit more from concurrency than ones with CPU-intensive tasks.$720
E$0$Concurrent tasks do not share the same memory.$720
A$0$The&nbsp;code&nbsp;compiles,&nbsp;and&nbsp;the&nbsp;output&nbsp;is&nbsp;0.$114
B$0$The&nbsp;code&nbsp;compiles,&nbsp;and&nbsp;the&nbsp;output&nbsp;is&nbsp;3.$114
C$0$The&nbsp;code&nbsp;compiles,&nbsp;and&nbsp;the&nbsp;output&nbsp;is&nbsp;7.$114
D$0$c&nbsp;instanceof&nbsp;Chipmunk&nbsp;does&nbsp;not&nbsp;compile.$114
E$1$l&nbsp;instanceof&nbsp;Chipmunk&nbsp;does&nbsp;not&nbsp;compile.$114
F$0$r&nbsp;instanceof&nbsp;Chipmunk&nbsp;does&nbsp;not&nbsp;compile.$114
A$1$Frog$214
B$1$TurtleFrog$214
C$0$BrazilianHornedFrog$214
D$1$CanHop$214
E$1$Object$214
F$0$Long$214
A$0$[55.&nbsp;88]&nbsp;[55,&nbsp;88]$314
B$0$[55.&nbsp;88]&nbsp;[88,&nbsp;55]$314
C$1$[88.&nbsp;55]&nbsp;[55,&nbsp;88]$314
D$0$[88.&nbsp;55]&nbsp;[88,&nbsp;55]$314
E$0$The&nbsp;code&nbsp;does&nbsp;not&nbsp;compile.$314
F$0$A&nbsp;runtime&nbsp;exception&nbsp;is&nbsp;thrown.$314
A$0$Line&nbsp;4&nbsp;does&nbsp;not&nbsp;compile.$414
B$0$Line&nbsp;5&nbsp;does&nbsp;not&nbsp;compile.$414
C$0$Line&nbsp;6&nbsp;does&nbsp;not&nbsp;compile.$414
D$1$Line&nbsp;7&nbsp;does&nbsp;not&nbsp;compile.$414
E$0$Line&nbsp;8&nbsp;does&nbsp;not&nbsp;compile.$414
F$0$The&nbsp;code&nbsp;throws&nbsp;an&nbsp;exception.$414
G$0$The&nbsp;code&nbsp;compiles&nbsp;and&nbsp;prints&nbsp;1.$414
A$0$//&nbsp;leave&nbsp;line&nbsp;blank$614
B$0$e&nbsp;=&nbsp;new&nbsp;Exception();$614
C$0$e&nbsp;=&nbsp;new&nbsp;RuntimeException();$614
D$0$e&nbsp;=&nbsp;new&nbsp;SneezeException();$614
E$0$e&nbsp;=&nbsp;new&nbsp;SniffleException();$614
F$1$None&nbsp;of&nbsp;the&nbsp;above;&nbsp;the&nbsp;code&nbsp;does&nbsp;not&nbsp;compile.$614
A$0$It&nbsp;outputs&nbsp;20&nbsp;85.$714
B$0$It&nbsp;outputs&nbsp;103&nbsp;85.$714
C$0$It&nbsp;outputs&nbsp;20&nbsp;103.$714
D$1$The&nbsp;code&nbsp;will&nbsp;not&nbsp;compile.$714
E$0$It&nbsp;compiles&nbsp;but&nbsp;throws&nbsp;an&nbsp;exception&nbsp;at&nbsp;runtime.$714
F$0$The&nbsp;output&nbsp;cannot&nbsp;be&nbsp;determined&nbsp;ahead&nbsp;of&nbsp;time.$714
A$0$The output is 0.$113
B$1$The output is 3.$113
C$0$The output is 7.$113
D$0$c instanceof Mammal does not compile.$113
E$0$c instanceof Furry does not compile.$113
F$0$null instanceof Chipmunk does not compile.$113
A$0$They don’t define any getter methods.$213
B$1$All of the instance variables marked private and final.$213
C$1$They don’t define any setter methods.$213
D$0$They mark all instance variables static.$213
E$1$They prevent methods from being overridden.$213
F$0$All getter methods are marked synchronized.$213
A$0$ArrayDeque&lt;?&gt; list = new ArrayDeque&lt;String&gt;();$313
B$1$ArrayList&lt;? super Date&gt; list = new ArrayList&lt;Date&gt;();$313
C$0$List&lt;?&gt; list = new ArrayList&lt;?&gt;();$313
D$0$List&lt;Exception&gt; list = new LinkedList&lt;java.io.IOException&gt;();$313
E$1$Vector&lt;? extends Number&gt; list = new Vector&lt;Integer&gt;();$313
F$0$None of the above$313
A$0$The code compiles and prints 123456.$413
B$0$The code compiles and prints 234567.$413
C$0$The code compiles but does not print anything.$413
D$0$The code compiles but prints stream references.$413
E$0$The code runs infinitely.$413
F$1$The code does not compile.$413
G$0$The code throws an exception$413
A$1$// leave line blank$613
B$0$e = new Exception();$613
C$0$e = new RuntimeException();$613
D$0$e = new SneezeException();$613
E$0$e = new SniffleException();$613
F$0$None of the above; the code does not compile.$613
A$1$It outputs 3 4.$713
B$0$It outputs 4 3.$713
C$0$The code will not compile because of line 6.$713
D$0$The code will not compile because of line 7.$713
E$0$The code will not compile because of line 8.$713
F$0$It compiles but throws an exception at runtime.$713
G$1$The collect() operation is always executed in a single-threaded fashion.$713
A$0$Inside Browser$112
B$0$Inside Firefox$112
C$0$Inside IE$112
D$0$The code does not compile.$112
E$1$A runtime exception is thrown.$112
A$0$ok$212
B$0$too high$212
C$1$Compiler error on line x1.$212
D$0$Compiler error on line x2.$212
E$0$Compiler error on a different line.$212
F$0$A runtime exception is thrown.$212
A$1$Helper.printException(new FileNotFoundException(&quot;A&quot;));$312
B$1$Helper.printException(new Exception(&quot;B&quot;));$312
C$0$Helper.&lt;Throwable&gt;printException(new Exception(&quot;C&quot;));$312
D$1$Helper.&lt;NullPointerException&gt;printException(new NullPointerException(&quot;D&quot;));$312
E$0$Helper.printException(new Throwable(&quot;E&quot;));$312
A$1$BiConsumer&lt;String, String&gt;$412
B$0$BiFunction&lt;String, String&gt;$412
C$0$BinaryConsumer&lt;String, String&gt;$412
D$0$BinaryFunction&lt;String, String&gt;$412
E$0$Consumer&lt;String&gt;$412
F$1$Supplier&lt;String&gt;$412
G$1$UnaryOperator&lt;String&gt;$412
H$0$UnaryOperator&lt;String, String&gt;$412
A$1$//leave line blank$612
B$0$e = new Exception();$612
C$0$e = new RuntimeException();$612
D$1$e = new SneezeException();$612
E$1$e = new SniffleException();$612
F$0$None of the above; the code does not compile.$612
A$0$It compiles and runs without issue.$712
B$0$The code will not compile because of m1.$712
C$0$The code will not compile because of m2.$712
D$0$The code will not compile because of m3.$712
E$1$It compiles but throws an exception at runtime.$712
F$0$It compiles but hangs at runtime.$712
A$0$import my.sports.Football;$111
B$1$import static my.sports.*;$111
C$0$import static my.sports.Football;$111
D$1$import static my.sports.Football.*;$111
E$0$static import my.sports.*;$111
F$0$static import my.sports.Football;$111
G$0$static import my.sports.Football.*;$111
A$1$caller((e) -&gt; &quot;Poof&quot;);$211
B$0$caller((e) -&gt; {&quot;Poof&quot;});$211
C$0$caller((e) -&gt; { String e = &quot;&quot;; &quot;Poof&quot; });$211
D$0$caller((e) -&gt; { String e = &quot;&quot;; return &quot;Poof&quot;; });$211
E$0$caller((e) -&gt; { String e = &quot;&quot;; return &quot;Poof&quot; });$211
F$1$caller((e) -&gt; { String f = &quot;&quot;; return &quot;Poof&quot;; });$211
A$1$16$311
B$0$25$311
C$0$Compiler error on line 3.$311
D$0$Compiler error on line 5.$311
E$0$Compiler error on line 7.$311
F$0$A runtime exception is thrown.$311
A$$Change Collectors.joining() to Collectors.joining(&quot;&quot;).$411
B$1$Change map(x -&gt; x) to map(x -&gt; &quot;&quot; + x) .$411
C$1$Change x -&gt; x++ to x -&gt; ++x.$411
D$$Add forEach(System.out::print) after the call to collect().$411
E$1$Wrap the entire line in a System.out.print statement.$411
F$0$None of the above. The code already prints 12345.$411
A$0$Exception$611
B$1$IllegalStateException$611
C$0$IOException$611
D$1$MissingResourceException$611
E$1$DateTimeParseException$611
F$0$SQLException$611
A$1$If the code does output anything, the order cannot be determined.$711
B$0$The code will always output Tortoise followed by Hare.$711
C$0$The code will always output Hare followed by Tortoise.$711
D$0$The code does not compile because of line t1.$711
E$0$The code does not compile because of line t2.$711
F$1$The code may produce a deadlock at runtime.$711
G$0$The code may produce a livelock at runtime.$711
H$0$It compiles but throws an exception at runtime.$711
A$0$x is 0.$109
B$1$x is 24.$109
C$0$Line 6 generates a compiler error.$109
D$0$Line 8 generates a compiler error.$109
E$0$Line 11 generates a compiler error.$109
F$0$An exception is thrown.$109
A$0$The output is 5.$108
B$0$The output is 10.$108
C$1$Line 4 generates a compiler error.$108
D$0$Line 8 generates a compiler error.$108
E$0$Line 9 generates a compiler error.$108
F$0$An exception is thrown.$108
A$0$vanilla$107
B$0$chocolate$107
C$0$strawberry$107
D$0$missing flavor$107
E$1$The code does not compile.$107
F$0$An exception is thrown.$107
A$0$0$106
B$1$1$106
C$0$9$106
D$0$CHOCOLATE$106
E$0$The code does not compile due to a missing semicolon.$106
F$0$The code does not compile for a different reason.$106
A$1$If a.equals(b) is true, a.hashCode() == b.hashCode() is always true.$105
B$0$If a.equals(b) is true, a.hashCode() == b.hashCode() is sometimes but not always true.$105
C$0$If a.equals(b) is false, a.hashCode() == b.hashCode() can never be true.$105
D$1$If a.equals(b) is false, a.hashCode() == b.hashCode() can sometimes be true.$105
A$0$The class does not compile.$104
B$0$The class compiles but has an improper equals() method.$104
C$1$The class compiles but has an improper hashCode() method.$104
D$0$The class compiles and has proper equals() and hashCode() methods.$104
A$0$There is no output.$103
B$0$s1 == s2$103
C$1$s1.equals(s2)$103
D$0$Both B and C.$103
E$0$The code does not compile.$103
F$0$The code throws a runtime exception.$103
A$0$The code compiles successfully, and one bytecode file is generated: Book.class.$110
B$0$The code compiles successfully, and two bytecode files are generated: Book.class and BookReader.class.$110
C$1$The code compiles successfully, and two bytecode files are generated: Book.class and Book&#36;BookReader.class.$110
D$0$A compiler error occurs on line 3.$110
E$0$A compiler error occurs on line 5.$110
A$0$The code compiles without issue.$210
B$0$The code will not compile because of line 5.$210
C$0$The code will not compile because of line 6.$210
D$1$The code will not compile because of line 8.$210
E$0$The code will not compile because of line 9.$210
A$1$Abb aab 123$310
B$0$aab Abb 123$310
C$0$123 Abb aab$310
D$0$123 aab Abb$310
E$0$The code does not compile.$310
F$0$A runtime exception is thrown.$310
A$0$L, N$410
B$0$L, N, O$410
C$0$L, N, M$410
D$0$L, N, M, O$410
E$0$L, O, M$410
F$1$N, M$410
G$0$N, O$410
A$1$Line 5 does not compile.$610
B$0$Lines 6 and 7 do not compile because they are missing the String message.$610
C$0$Lines 6 and 7 do not compile because they are missing parentheses.$610
D$0$Line 6 is an appropriate use of an assertion.$610
E$1$Line 7 is an appropriate use of an assertion.$610
A$0$It compiles and runs without issue, outputting the total length of all strings in the stream.$710
B$0$The code will not compile because of line q1.$710
C$1$The code will not compile because of line q2.$710
D$0$The code will not compile because of line q3.$710
E$0$It compiles but throws an exception at runtime.$710
A$0$A design principle is focused on solving a specific commonly occurring problem.$201
B$0$Design principles and design patterns are the same thing.$201
C$1$Design principles are often applied throughout an application, whereas design patterns are applied to solve specific problems.$201
D$0$Design patterns can only be applied to static classes.$201
E$1$Design principles and design patterns tend to produce code that is easier to maintain and easier for other developers to read.$201
A$0$It compiles and runs without issue.$202
B$0$The code will not compile because of line 2.$202
C$0$The code will not compile because of line 4.$202
D$0$The code will not compile because of line 5.$202
E$1$The code will not compile because of line 8.$202
F$0$It compiles but throws an exception at runtime.$202
A$1$Climb$203
B$0$Swim$203
C$0$ArcticMountainClimb$203
D$1$MountainClimb$203
E$0$None of these are valid functional interfaces.$203
A$1$() -&gt; &quot;&quot;$204
B$0$x,y -&gt; x+y$204
C$0$(Coyote y) -&gt; return 0;$204
D$1$(Camel c) -&gt; {return;}$204
E$0$Wolf w -&gt; 39$204
F$0$() -&gt;$204
G$0$(Animal z, m) -&gt; a$204
A$0$Singleton object can be replaced with encapsulated setter method.$205
B$1$Requires constructor of singleton class to be private.$205
C$0$Singleton object must be named instance.$205
D$0$Singleton object may be private or protected.$205
E$1$Ensures that there is only one instance of an object in memory.$205
F$1$Requires a public static method to retrieve the instance of the singleton.$205
A$1$match$206
B$0$not match$206
C$0$Compiler error on line h1.$206
D$0$Compiler error on line h2.$206
E$0$Compile error on line h3.$206
F$0$A runtime exception is thrown.$206
A$0$None; the immutable object pattern is properly implemented.$207
B$0$Have Seal implement the Immutable interface.$207
C$1$Mark name final and private.$207
D$0$Add setters for name and List&lt;Seal&gt; friends.$207
E$1$Replace the getFriends() method with methods that do not give the caller direct access to the List&lt;Seal&gt; friends.$207
F$0$Change the type of List&lt;Seal&gt; to List&lt;Object&gt;.$207
G$1$Make a copy of the List&lt;Seal&gt; friends in the constructor.$207
H$1$Mark the Seal class final.$207
A$0$They can extend other classes.$208
B$0$They cannot be extended.$208
C$1$They enable classes to have multiple inheritance.$208
D$0$They can only contain abstract methods.$208
E$0$They can be declared final.$208
F$1$All members of an interface are public.$208
A$0$None; the singleton pattern is properly implemented.$209
B$0$Rename cheetahManager to instance.$209
C$0$Rename getCheetahManager() to getInstance().$209
D$1$Change the access modifier of cheetahManager from public to private.$209
E$0$Mark cheetahManager final.$209
F$1$Add synchronized to getCheetahManager().$209
