ID|CONTENT|EXPLANATION|CHAPTER_ID
101|What is the result of the following code?<br/>1:    public class Employee {<br/>2:       public int employeeId;<br/>3:       public String firstName, lastName;<br/>4:       public int yearStarted;<br/>5:       @Override public int hashCode() {<br/>6:          return employeeId;<br/>7:       }<br/>8:       public boolean equals(Employee e) {<br/>9:          return this.employeeId == e.employeeId;<br/>10:      }<br/>11:      public static void main(String[] args) {<br/>12:         Employee one = new Employee();<br/>13:         one.employeeId = 101;<br/>14:         Employee two = new Employee();<br/>15:         two.employeeId = 101;<br/>16:         if (one.equals(two)) System.out.println("Success");<br/>17:         else System.out.println("Failure");<br/>18:     } }<br/> | |1
115|Which of the following statements are true about the equals() method? (Choose all that apply.)|B, E. equals() should return false when the object it passed in is not equal to the current object. This includes null and incorrect types. An equals() method should have a null check and an instanceof check. |1
215|Which of the following statements about polymorphism are true? (Choose all that apply.)|B, C. A reference to an object requires an explicit cast if referenced with a subclass, so A is incorrect. If the cast is to a superclass reference, then an explicit cast is not required, so C is correct. If a method takes the superclass of an object as a parameter, then any subclass references may be used without a cast, so B is correct. Some cast exceptions can be detected as errors at compile-time, but others can only be detected at runtime, so D is incorrect. Due to the nature of polymorphism, a public instance method can be overridden in a subclass and calls to it will be replaced even in the superclass in which it was defined, so E is incorrect.|2
315|What is the result of the following code?<br/> Comparator<Integer> c = (o1, o2) -> o2â€”o1;<br/> List<Integer> list = Arrays.asList(5, 4, 7, 1);<br/> Collections.sort(list, c);<br/> System.out.println(Collections.binarySearch(list, 1));|D. The list is sorted in descending order. However, it is searched using the default order, which is sorted in ascending order. binarySearch() requires both to use the same sort order. Therefore, the precondition for binarySearch() is not met and the result is undefined.|3
415|The partitioningBy() collector creates a Map<Boolean, List<String>> when passed to collect() by default. When specific parameters are passed to partitioningBy(), which return types can be created? (Choose all that apply.)|D, E. Choices A and B do not compile, because they are invalid generic declarations. Primitives are not allowed as generics, and Map must have two generic types. Choice C is incorrect because partitioning only gives a Boolean key. Choices D and E are correct because the result Collection can be customized.|4
615|class One extends RuntimeException{}<br/>class Two extends Exception{}<br/>class Three extends Error{}<br/>class Four extends One{}<br/>class Five extends Two{}<br/>class Six extends Three{}|B, E. A checked exception extends Exception but not RuntimeException. The entire hierarchy counts, so B and E are both correct.|6
715|Which of the following are valid Callable expressions? (Choose all that apply.)|C, E, G. A Callable lambda expression takes no values and returns a generic type; therefore C, E, and G are correct. A and F are incorrect because they both take an input parameter. B is a Runnable lambda expression, because it does not return a value, but it is not a|7
