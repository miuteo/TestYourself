ID|CONTENT|EXPLANATION|CHAPTER_ID
101|What is the result of the following code?<br/>1:    public class Employee {<br/>2:       public int employeeId;<br/>3:       public String firstName, lastName;<br/>4:       public int yearStarted;<br/>5:       @Override public int hashCode() {<br/>6:          return employeeId;<br/>7:       }<br/>8:       public boolean equals(Employee e) {<br/>9:          return this.employeeId == e.employeeId;<br/>10:      }<br/>11:      public static void main(String[] args) {<br/>12:         Employee one = new Employee();<br/>13:         one.employeeId = 101;<br/>14:         Employee two = new Employee();<br/>15:         two.employeeId = 101;<br/>16:         if (one.equals(two)) System.out.println("Success");<br/>17:         else System.out.println("Failure");<br/>18:     } }<br/> | |1
115|Which of the following statements are true about the equals() method? (Choose all that apply.)|B, E. equals() should return false when the object it passed in is not equal to the current object. This includes null and incorrect types. An equals() method should have a null check and an instanceof check. |1
215|Which of the following statements about polymorphism are true? (Choose all that apply.)|B, C. A reference to an object requires an explicit cast if referenced with a subclass, so A is incorrect. If the cast is to a superclass reference, then an explicit cast is not required, so C is correct. If a method takes the superclass of an object as a parameter, then any subclass references may be used without a cast, so B is correct. Some cast exceptions can be detected as errors at compile-time, but others can only be detected at runtime, so D is incorrect. Due to the nature of polymorphism, a public instance method can be overridden in a subclass and calls to it will be replaced even in the superclass in which it was defined, so E is incorrect.|2
315|What is the result of the following code?<br/> Comparator<Integer> c = (o1, o2) -> o2â€”o1;<br/> List<Integer> list = Arrays.asList(5, 4, 7, 1);<br/> Collections.sort(list, c);<br/> System.out.println(Collections.binarySearch(list, 1));|D. The list is sorted in descending order. However, it is searched using the default order, which is sorted in ascending order. binarySearch() requires both to use the same sort order. Therefore, the precondition for binarySearch() is not met and the result is undefined.|3
415|The partitioningBy() collector creates a Map<Boolean, List<String>> when passed to collect() by default. When specific parameters are passed to partitioningBy(), which return types can be created? (Choose all that apply.)|D, E. Choices A and B do not compile, because they are invalid generic declarations. Primitives are not allowed as generics, and Map must have two generic types. Choice C is incorrect because partitioning only gives a Boolean key. Choices D and E are correct because the result Collection can be customized.|4
615|class One extends RuntimeException{}<br/>class Two extends Exception{}<br/>class Three extends Error{}<br/>class Four extends One{}<br/>class Five extends Two{}<br/>class Six extends Three{}|B, E. A checked exception extends Exception but not RuntimeException. The entire hierarchy counts, so B and E are both correct.|6
715|Which of the following are valid Callable expressions? (Choose all that apply.)|C, E, G. A Callable lambda expression takes no values and returns a generic type; therefore C, E, and G are correct. A and F are incorrect because they both take an input parameter. B is a Runnable lambda expression, because it does not return a value, but it is not a|7
116|public class Outer {<br/>class Inner { }<br/>public static void main(String[] args) {<br/>// INSERT CODE HERE<br/>} }|E. This is a member inner class. It needs to be created using an instance of the outer class.<br/>The syntax looks weird, but it creates an object of the outer class and then an object of the<br/>inner class from it.|1
216|1: public interface Herbivore {<br/>2: int amount = 10;<br/>3: public static void eatGrass();<br/>4: public int chew() {<br/>5: return 13;<br/>6: }<br/>7: }<br/>|F. The interface variable amount is correctly declared, with public, static, and final<br/>being assumed and automatically inserted by the compiler, so B is incorrect. The method<br/>declaration for eatGrass() on line 3 is incorrect because the method has been marked as<br/>static but no method body has been provided. The method declaration for chew() on<br/>line 4 is also incorrect, since an interface method that provides a body must be marked as<br/>default or static explicitly. Therefore, F is the correct answer since this code contains<br/>two compile-time errors.|2
316|Which of the following statements are true? (Choose all that apply.)|B, D, F. The java.lang.Comparable interface is implemented on the object to compare. It specifies the compareTo() method, which takes one parameter. The java. util.Comparator interface specifies the compare() method, which takes two parameters.|3
416|What is the output of the following?<br/>Stream<String> s = Stream.empty();<br/>Stream<String> s2 = Stream.empty();<br/>Map<Boolean, List<String>> p = s.collect(<br/>Collectors.partitioningBy(b -> b.startsWith("c")));<br/>Map<Boolean, List<String>> g = s2.collect(<br/>Collectors.groupingBy(b -> b.startsWith("c")));<br/>System.out.println(p + " " + g);|C. The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values. By contrast, groupingBy() returns only keys that are actually needed.|4
616|public class Test {<br/>    static class Door implements AutoCloseable {<br/>        public void close() {<br/>            System.out.print("D");<br/>            throw new RuntimeException();<br/>        } }<br/>    static class Window implements Closeable {<br/>        public void close() {<br/>            System.out.print("W");<br/>            throw new RuntimeException();<br/>        } }<br/>    public static void main(String[] args) {<br/>        try(Door door = new Door(); Window w = new Window();) {<br/>            System.out.print("T");<br/>        }<br/>         catch (Exception e) {<br/>            System.out.print("E");<br/>        } finally {<br/>            System.out.print("F");<br/>        } } }|C. The exception inside the try block becomes the primary exception since it is thrown first. Then two suppressed exceptions are added to it when trying to close the AutoCloseable resources.|6
716|What is the result of executing the following application? (Choose all that apply.)<br/>import java.util.concurrent.*;<br/>import java.util.stream.*;<br/>public class PrintConstants {<br/>public static void main(String[] args) {<br/>ExecutorService service = Executors.newScheduledThreadPool(10);<br/>DoubleStream.of(3.14159,2.71828) // b1<br/>.forEach(c -> service.submit( // b2<br/>() -> System.out.println(10*c))); // b3<br/>service.execute(() -> System.out.println("Printed")); // b4<br/>}<br/>}|F, H. The application compiles and does not throw an exception, so B, C, D, E, and G are incorrect. Even though the stream is processed in sequential order, the tasks are submitted to a thread executor, which may complete the tasks in any order. Therefore, the output cannot be determined ahead of time and F is correct, making A incorrect. Finally, the thread executor is never shut down; therefore the code will run but it will never terminate, making H also correct.|7
