ID|CONTENT|EXPLANATION|CHAPTER_ID
101|What is the result of the following code?<br/>1:    public class Employee {<br/>2:       public int employeeId;<br/>3:       public String firstName, lastName;<br/>4:       public int yearStarted;<br/>5:       @Override public int hashCode() {<br/>6:          return employeeId;<br/>7:       }<br/>8:       public boolean equals(Employee e) {<br/>9:          return this.employeeId == e.employeeId;<br/>10:      }<br/>11:      public static void main(String[] args) {<br/>12:         Employee one = new Employee();<br/>13:         one.employeeId = 101;<br/>14:         Employee two = new Employee();<br/>15:         two.employeeId = 101;<br/>16:         if (one.equals(two)) System.out.println("Success");<br/>17:         else System.out.println("Failure");<br/>18:     } }<br/> | |1
115|Which of the following statements are true about the equals() method? (Choose all that apply.)|B, E. equals() should return false when the object it passed in is not equal to the current object. This includes null and incorrect types. An equals() method should have a null check and an instanceof check. |1
215|Which of the following statements about polymorphism are true? (Choose all that apply.)|B, C. A reference to an object requires an explicit cast if referenced with a subclass, so A is incorrect. If the cast is to a superclass reference, then an explicit cast is not required, so C is correct. If a method takes the superclass of an object as a parameter, then any subclass references may be used without a cast, so B is correct. Some cast exceptions can be detected as errors at compile-time, but others can only be detected at runtime, so D is incorrect. Due to the nature of polymorphism, a public instance method can be overridden in a subclass and calls to it will be replaced even in the superclass in which it was defined, so E is incorrect.|2
315|What is the result of the following code?<br/> Comparator<Integer> c = (o1, o2) -> o2—o1;<br/> List<Integer> list = Arrays.asList(5, 4, 7, 1);<br/> Collections.sort(list, c);<br/> System.out.println(Collections.binarySearch(list, 1));|D. The list is sorted in descending order. However, it is searched using the default order, which is sorted in ascending order. binarySearch() requires both to use the same sort order. Therefore, the precondition for binarySearch() is not met and the result is undefined.|3
415|The partitioningBy() collector creates a Map<Boolean, List<String>> when passed to collect() by default. When specific parameters are passed to partitioningBy(), which return types can be created? (Choose all that apply.)|D, E. Choices A and B do not compile, because they are invalid generic declarations. Primitives are not allowed as generics, and Map must have two generic types. Choice C is incorrect because partitioning only gives a Boolean key. Choices D and E are correct because the result Collection can be customized.|4
615|class One extends RuntimeException{}<br/>class Two extends Exception{}<br/>class Three extends Error{}<br/>class Four extends One{}<br/>class Five extends Two{}<br/>class Six extends Three{}|B, E. A checked exception extends Exception but not RuntimeException. The entire hierarchy counts, so B and E are both correct.|6
715|Which of the following are valid Callable expressions? (Choose all that apply.)|C, E, G. A Callable lambda expression takes no values and returns a generic type; therefore C, E, and G are correct. A and F are incorrect because they both take an input parameter. B is a Runnable lambda expression, because it does not return a value, but it is not a|7
116|public class Outer {<br/>class Inner { }<br/>public static void main(String[] args) {<br/>// INSERT CODE HERE<br/>} }|E. This is a member inner class. It needs to be created using an instance of the outer class.<br/>The syntax looks weird, but it creates an object of the outer class and then an object of the<br/>inner class from it.|1
216|1: public interface Herbivore {<br/>2: int amount = 10;<br/>3: public static void eatGrass();<br/>4: public int chew() {<br/>5: return 13;<br/>6: }<br/>7: }<br/>|F. The interface variable amount is correctly declared, with public, static, and final<br/>being assumed and automatically inserted by the compiler, so B is incorrect. The method<br/>declaration for eatGrass() on line 3 is incorrect because the method has been marked as<br/>static but no method body has been provided. The method declaration for chew() on<br/>line 4 is also incorrect, since an interface method that provides a body must be marked as<br/>default or static explicitly. Therefore, F is the correct answer since this code contains<br/>two compile-time errors.|2
316|Which of the following statements are true? (Choose all that apply.)|B, D, F. The java.lang.Comparable interface is implemented on the object to compare. It specifies the compareTo() method, which takes one parameter. The java. util.Comparator interface specifies the compare() method, which takes two parameters.|3
416|What is the output of the following?<br/>Stream<String> s = Stream.empty();<br/>Stream<String> s2 = Stream.empty();<br/>Map<Boolean, List<String>> p = s.collect(<br/>Collectors.partitioningBy(b -> b.startsWith("c")));<br/>Map<Boolean, List<String>> g = s2.collect(<br/>Collectors.groupingBy(b -> b.startsWith("c")));<br/>System.out.println(p + " " + g);|C. The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values. By contrast, groupingBy() returns only keys that are actually needed.|4
616|public class Test {<br/>    static class Door implements AutoCloseable {<br/>        public void close() {<br/>            System.out.print("D");<br/>            throw new RuntimeException();<br/>        } }<br/>    static class Window implements Closeable {<br/>        public void close() {<br/>            System.out.print("W");<br/>            throw new RuntimeException();<br/>        } }<br/>    public static void main(String[] args) {<br/>        try(Door door = new Door(); Window w = new Window();) {<br/>            System.out.print("T");<br/>        }<br/>         catch (Exception e) {<br/>            System.out.print("E");<br/>        } finally {<br/>            System.out.print("F");<br/>        } } }|C. The exception inside the try block becomes the primary exception since it is thrown first. Then two suppressed exceptions are added to it when trying to close the AutoCloseable resources.|6
716|What is the result of executing the following application? (Choose all that apply.)<br/>import java.util.concurrent.*;<br/>import java.util.stream.*;<br/>public class PrintConstants {<br/>public static void main(String[] args) {<br/>ExecutorService service = Executors.newScheduledThreadPool(10);<br/>DoubleStream.of(3.14159,2.71828) // b1<br/>.forEach(c -> service.submit( // b2<br/>() -> System.out.println(10*c))); // b3<br/>service.execute(() -> System.out.println("Printed")); // b4<br/>}<br/>}|F, H. The application compiles and does not throw an exception, so B, C, D, E, and G are incorrect. Even though the stream is processed in sequential order, the tasks are submitted to a thread executor, which may complete the tasks in any order. Therefore, the output cannot be determined ahead of time and F is correct, making A incorrect. Finally, the thread executor is never shut down; therefore the code will run but it will never terminate, making H also correct.|7
117|What is the result of the following code? (Choose all that apply.)<br/>1: public enum AnimalClasses {<br/>2: MAMMAL(true), FISH(Boolean.FALSE), BIRD(false),<br/>3: REPTILE(false), AMPHIBIAN(false), INVERTEBRATE(false)<br/>4: boolean hasHair;<br/>5: public AnimalClasses(boolean hasHair) {<br/>6: this.hasHair = hasHair;<br/>7: }<br/>8: public boolean hasHair() {<br/>9: return hasHair;<br/>10: }<br/>11: public void giveWig() {<br/>12: hasHair = true;<br/>13: } }|B, C. Enums are required to have a semicolon after the list of values if there is anything else in the enum. Don’t worry; you won’t be expected to track down missing semicolons on the whole exam—only on enum questions. Enums are not allowed to have a public constructor.|1
217|Which of the following are properties of classes that are properly encapsulated as a JavaBean? (Choose all that apply.)|B, C, F. Options B, C, and F are each correct statements about JavaBean encapsulation.A is incorrect, as that is a property of the immutable object pattern, not encapsulation. D is incorrect, as there is no such JavaBean interface defined in the Java API. Finally, E is incorrect, as handling instantiation is not part of encapsulation.|2
317|Which two options can fill in the blanks to make this code compile? (Choose all that apply.)<br/>1: public class Generic________ {<br/>2: public static void main(String[] args) {<br/>3: Generic<String> g = new Generic_______();<br/>4: Generic<Object> g2 = new Generic();<br/>5: }<br/>6: }<br/>|B, D. Line 1 is a generic class that requires specifying a name for the type. Options A and C are incorrect because no type is specified. Line 3 tries to use the diamond operator to instantiate the class. Option E is incorrect because T is not a class and certainly not one compatible with String. Option F is incorrect because a wildcard cannot be specified on the right side when instantiating an object.|3
417|Which of the following is equivalent to this code?<br/>UnaryOperator<Integer> u = x -> x * x;|E. A UnaryOperator is a special type of function where the parameter and return type are the same. Therefore, option E is correct. Notice that other options don’t even compile because they have the wrong number of generic types for the functional interface provided.|4
617|Fill in the blank: A class that implements _________________ may be in a try-with-resource<br/>statement. (Choose all that apply.)|A, B. Closeable was the original interface for IO classes. AutoCloseable was added in Java 7 along with try-with-resources. Closeable extends AutoCloseable for backward compatibility.|6
717|Assuming 100 milliseconds is enough time for the tasks submitted to the thread executor to<br/>complete, what is the result of executing the following program? (Choose all that apply.)<br/>import java.util.concurrent.*;<br/>public class SheepManager {<br/>private static AtomicInteger sheepCount1 = new AtomicInteger(0); // w1<br/>private static int sheepCount2 = 0;<br/>public static void main(String[] args) throws InterruptedException {<br/>ExecutorService service = null;<br/>try {<br/>service = Executors.newSingleThreadExecutor(); // w2<br/>for(int i=0; i<100; i++)<br/>service.execute(() -><br/>{sheepCount1.getAndIncrement(); sheepCount2++;}); // w3<br/>Thread.sleep(100);<br/>System.out.println(sheepCount1+" "+sheepCount2);<br/>} finally {<br/>if(service != null) service.shutdown();<br/>}<br/>}|B. The code compiles and runs without issue, so D, E, F, and G are incorrect. The key aspect to notice in the code is that a single-thread executor is used, meaning that no task will be executed concurrently. Therefore, the results are valid and predictable with 100 100 being the output, and B is the correct answer. If a pooled thread executor was used with at least two threads, then the sheepCount2++ operations could overwrite each other, making the second value indeterminate at the end of the program. In this case, C would be the correct answer.|7
