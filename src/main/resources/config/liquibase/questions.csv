ID$CONTENT$EXPLANATION$CHAPTER_ID
101$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?<br/>1:&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Employee&nbsp;{<br/>2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;employeeId;<br/>3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;firstName,&nbsp;lastName;<br/>4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;yearStarted;<br/>5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;{<br/>6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;employeeId;<br/>7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Employee&nbsp;e)&nbsp;{<br/>9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.employeeId&nbsp;==&nbsp;e.employeeId;<br/>10:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>11:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>12:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;one&nbsp;=&nbsp;new&nbsp;Employee();<br/>13:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.employeeId&nbsp;=&nbsp;101;<br/>14:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;two&nbsp;=&nbsp;new&nbsp;Employee();<br/>15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.employeeId&nbsp;=&nbsp;101;<br/>16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(one.equals(two))&nbsp;System.out.println(&quot;Success&quot;);<br/>17:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;System.out.println(&quot;Failure&quot;);<br/>18:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;}<br/>&nbsp;$&nbsp;$1
115$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;statements&nbsp;are&nbsp;true&nbsp;about&nbsp;the&nbsp;equals()&nbsp;method?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$B,&nbsp;E.&nbsp;equals()&nbsp;should&nbsp;return&nbsp;false&nbsp;when&nbsp;the&nbsp;object&nbsp;it&nbsp;passed&nbsp;in&nbsp;is&nbsp;not&nbsp;equal&nbsp;to&nbsp;the&nbsp;current&nbsp;object.&nbsp;This&nbsp;includes&nbsp;null&nbsp;and&nbsp;incorrect&nbsp;types.&nbsp;An&nbsp;equals()&nbsp;method&nbsp;should&nbsp;have&nbsp;a&nbsp;null&nbsp;check&nbsp;and&nbsp;an&nbsp;instanceof&nbsp;check.&nbsp;$1
215$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;statements&nbsp;about&nbsp;polymorphism&nbsp;are&nbsp;true?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$B,&nbsp;C.&nbsp;A&nbsp;reference&nbsp;to&nbsp;an&nbsp;object&nbsp;requires&nbsp;an&nbsp;explicit&nbsp;cast&nbsp;if&nbsp;referenced&nbsp;with&nbsp;a&nbsp;subclass,&nbsp;so&nbsp;A&nbsp;is&nbsp;incorrect.&nbsp;If&nbsp;the&nbsp;cast&nbsp;is&nbsp;to&nbsp;a&nbsp;superclass&nbsp;reference,&nbsp;then&nbsp;an&nbsp;explicit&nbsp;cast&nbsp;is&nbsp;not&nbsp;required,&nbsp;so&nbsp;C&nbsp;is&nbsp;correct.&nbsp;If&nbsp;a&nbsp;method&nbsp;takes&nbsp;the&nbsp;superclass&nbsp;of&nbsp;an&nbsp;object&nbsp;as&nbsp;a&nbsp;parameter,&nbsp;then&nbsp;any&nbsp;subclass&nbsp;references&nbsp;may&nbsp;be&nbsp;used&nbsp;without&nbsp;a&nbsp;cast,&nbsp;so&nbsp;B&nbsp;is&nbsp;correct.&nbsp;Some&nbsp;cast&nbsp;exceptions&nbsp;can&nbsp;be&nbsp;detected&nbsp;as&nbsp;errors&nbsp;at&nbsp;compile-time,&nbsp;but&nbsp;others&nbsp;can&nbsp;only&nbsp;be&nbsp;detected&nbsp;at&nbsp;runtime,&nbsp;so&nbsp;D&nbsp;is&nbsp;incorrect.&nbsp;Due&nbsp;to&nbsp;the&nbsp;nature&nbsp;of&nbsp;polymorphism,&nbsp;a&nbsp;public&nbsp;instance&nbsp;method&nbsp;can&nbsp;be&nbsp;overridden&nbsp;in&nbsp;a&nbsp;subclass&nbsp;and&nbsp;calls&nbsp;to&nbsp;it&nbsp;will&nbsp;be&nbsp;replaced&nbsp;even&nbsp;in&nbsp;the&nbsp;superclass&nbsp;in&nbsp;which&nbsp;it&nbsp;was&nbsp;defined,&nbsp;so&nbsp;E&nbsp;is&nbsp;incorrect.$2
315$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?<br/>&nbsp;Comparator&lt;Integer&gt;&nbsp;c&nbsp;=&nbsp;(o1,&nbsp;o2)&nbsp;-&gt;&nbsp;o2—o1;<br/>&nbsp;List&lt;Integer&gt;&nbsp;list&nbsp;=&nbsp;Arrays.asList(5,&nbsp;4,&nbsp;7,&nbsp;1);<br/>&nbsp;Collections.sort(list,&nbsp;c);<br/>&nbsp;System.out.println(Collections.binarySearch(list,&nbsp;1));$D.&nbsp;The&nbsp;list&nbsp;is&nbsp;sorted&nbsp;in&nbsp;descending&nbsp;order.&nbsp;However,&nbsp;it&nbsp;is&nbsp;searched&nbsp;using&nbsp;the&nbsp;default&nbsp;order,&nbsp;which&nbsp;is&nbsp;sorted&nbsp;in&nbsp;ascending&nbsp;order.&nbsp;binarySearch()&nbsp;requires&nbsp;both&nbsp;to&nbsp;use&nbsp;the&nbsp;same&nbsp;sort&nbsp;order.&nbsp;Therefore,&nbsp;the&nbsp;precondition&nbsp;for&nbsp;binarySearch()&nbsp;is&nbsp;not&nbsp;met&nbsp;and&nbsp;the&nbsp;result&nbsp;is&nbsp;undefined.$3
415$The&nbsp;partitioningBy()&nbsp;collector&nbsp;creates&nbsp;a&nbsp;Map&lt;Boolean,&nbsp;List&lt;String&gt;&gt;&nbsp;when&nbsp;passed&nbsp;to&nbsp;collect()&nbsp;by&nbsp;default.&nbsp;When&nbsp;specific&nbsp;parameters&nbsp;are&nbsp;passed&nbsp;to&nbsp;partitioningBy(),&nbsp;which&nbsp;return&nbsp;types&nbsp;can&nbsp;be&nbsp;created?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$D,&nbsp;E.&nbsp;Choices&nbsp;A&nbsp;and&nbsp;B&nbsp;do&nbsp;not&nbsp;compile,&nbsp;because&nbsp;they&nbsp;are&nbsp;invalid&nbsp;generic&nbsp;declarations.&nbsp;Primitives&nbsp;are&nbsp;not&nbsp;allowed&nbsp;as&nbsp;generics,&nbsp;and&nbsp;Map&nbsp;must&nbsp;have&nbsp;two&nbsp;generic&nbsp;types.&nbsp;Choice&nbsp;C&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;partitioning&nbsp;only&nbsp;gives&nbsp;a&nbsp;Boolean&nbsp;key.&nbsp;Choices&nbsp;D&nbsp;and&nbsp;E&nbsp;are&nbsp;correct&nbsp;because&nbsp;the&nbsp;result&nbsp;Collection&nbsp;can&nbsp;be&nbsp;customized.$4
615$class&nbsp;One&nbsp;extends&nbsp;RuntimeException{}<br/>class&nbsp;Two&nbsp;extends&nbsp;Exception{}<br/>class&nbsp;Three&nbsp;extends&nbsp;Error{}<br/>class&nbsp;Four&nbsp;extends&nbsp;One{}<br/>class&nbsp;Five&nbsp;extends&nbsp;Two{}<br/>class&nbsp;Six&nbsp;extends&nbsp;Three{}$B,&nbsp;E.&nbsp;A&nbsp;checked&nbsp;exception&nbsp;extends&nbsp;Exception&nbsp;but&nbsp;not&nbsp;RuntimeException.&nbsp;The&nbsp;entire&nbsp;hierarchy&nbsp;counts,&nbsp;so&nbsp;B&nbsp;and&nbsp;E&nbsp;are&nbsp;both&nbsp;correct.$6
715$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;are&nbsp;valid&nbsp;Callable&nbsp;expressions?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$C,&nbsp;E,&nbsp;G.&nbsp;A&nbsp;Callable&nbsp;lambda&nbsp;expression&nbsp;takes&nbsp;no&nbsp;values&nbsp;and&nbsp;returns&nbsp;a&nbsp;generic&nbsp;type;&nbsp;therefore&nbsp;C,&nbsp;E,&nbsp;and&nbsp;G&nbsp;are&nbsp;correct.&nbsp;A&nbsp;and&nbsp;F&nbsp;are&nbsp;incorrect&nbsp;because&nbsp;they&nbsp;both&nbsp;take&nbsp;an&nbsp;input&nbsp;parameter.&nbsp;B&nbsp;is&nbsp;a&nbsp;Runnable&nbsp;lambda&nbsp;expression,&nbsp;because&nbsp;it&nbsp;does&nbsp;not&nbsp;return&nbsp;a&nbsp;value,&nbsp;but&nbsp;it&nbsp;is&nbsp;not&nbsp;a$7
116$public&nbsp;class&nbsp;Outer&nbsp;{<br/>class&nbsp;Inner&nbsp;{&nbsp;}<br/>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>//&nbsp;INSERT&nbsp;CODE&nbsp;HERE<br/>}&nbsp;}$E.&nbsp;This&nbsp;is&nbsp;a&nbsp;member&nbsp;inner&nbsp;class.&nbsp;It&nbsp;needs&nbsp;to&nbsp;be&nbsp;created&nbsp;using&nbsp;an&nbsp;instance&nbsp;of&nbsp;the&nbsp;outer&nbsp;class.<br/>The&nbsp;syntax&nbsp;looks&nbsp;weird,&nbsp;but&nbsp;it&nbsp;creates&nbsp;an&nbsp;object&nbsp;of&nbsp;the&nbsp;outer&nbsp;class&nbsp;and&nbsp;then&nbsp;an&nbsp;object&nbsp;of&nbsp;the<br/>inner&nbsp;class&nbsp;from&nbsp;it.$1
216$1:&nbsp;public&nbsp;interface&nbsp;Herbivore&nbsp;{<br/>2:&nbsp;int&nbsp;amount&nbsp;=&nbsp;10;<br/>3:&nbsp;public&nbsp;static&nbsp;void&nbsp;eatGrass();<br/>4:&nbsp;public&nbsp;int&nbsp;chew()&nbsp;{<br/>5:&nbsp;return&nbsp;13;<br/>6:&nbsp;}<br/>7:&nbsp;}<br/>$F.&nbsp;The&nbsp;interface&nbsp;variable&nbsp;amount&nbsp;is&nbsp;correctly&nbsp;declared,&nbsp;with&nbsp;public,&nbsp;static,&nbsp;and&nbsp;final<br/>being&nbsp;assumed&nbsp;and&nbsp;automatically&nbsp;inserted&nbsp;by&nbsp;the&nbsp;compiler,&nbsp;so&nbsp;B&nbsp;is&nbsp;incorrect.&nbsp;The&nbsp;method<br/>declaration&nbsp;for&nbsp;eatGrass()&nbsp;on&nbsp;line&nbsp;3&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;the&nbsp;method&nbsp;has&nbsp;been&nbsp;marked&nbsp;as<br/>static&nbsp;but&nbsp;no&nbsp;method&nbsp;body&nbsp;has&nbsp;been&nbsp;provided.&nbsp;The&nbsp;method&nbsp;declaration&nbsp;for&nbsp;chew()&nbsp;on<br/>line&nbsp;4&nbsp;is&nbsp;also&nbsp;incorrect,&nbsp;since&nbsp;an&nbsp;interface&nbsp;method&nbsp;that&nbsp;provides&nbsp;a&nbsp;body&nbsp;must&nbsp;be&nbsp;marked&nbsp;as<br/>default&nbsp;or&nbsp;static&nbsp;explicitly.&nbsp;Therefore,&nbsp;F&nbsp;is&nbsp;the&nbsp;correct&nbsp;answer&nbsp;since&nbsp;this&nbsp;code&nbsp;contains<br/>two&nbsp;compile-time&nbsp;errors.$2
316$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;statements&nbsp;are&nbsp;true?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$B,&nbsp;D,&nbsp;F.&nbsp;The&nbsp;java.lang.Comparable&nbsp;interface&nbsp;is&nbsp;implemented&nbsp;on&nbsp;the&nbsp;object&nbsp;to&nbsp;compare.&nbsp;It&nbsp;specifies&nbsp;the&nbsp;compareTo()&nbsp;method,&nbsp;which&nbsp;takes&nbsp;one&nbsp;parameter.&nbsp;The&nbsp;java.&nbsp;util.Comparator&nbsp;interface&nbsp;specifies&nbsp;the&nbsp;compare()&nbsp;method,&nbsp;which&nbsp;takes&nbsp;two&nbsp;parameters.$3
416$What&nbsp;is&nbsp;the&nbsp;output&nbsp;of&nbsp;the&nbsp;following?<br/>Stream&lt;String&gt;&nbsp;s&nbsp;=&nbsp;Stream.empty();<br/>Stream&lt;String&gt;&nbsp;s2&nbsp;=&nbsp;Stream.empty();<br/>Map&lt;Boolean,&nbsp;List&lt;String&gt;&gt;&nbsp;p&nbsp;=&nbsp;s.collect(<br/>Collectors.partitioningBy(b&nbsp;-&gt;&nbsp;b.startsWith(&quot;c&quot;)));<br/>Map&lt;Boolean,&nbsp;List&lt;String&gt;&gt;&nbsp;g&nbsp;=&nbsp;s2.collect(<br/>Collectors.groupingBy(b&nbsp;-&gt;&nbsp;b.startsWith(&quot;c&quot;)));<br/>System.out.println(p&nbsp;+&nbsp;&quot;&nbsp;&quot;&nbsp;+&nbsp;g);$C.&nbsp;The&nbsp;partitioningBy()&nbsp;operation&nbsp;always&nbsp;returns&nbsp;a&nbsp;map&nbsp;with&nbsp;two&nbsp;Boolean&nbsp;keys,&nbsp;even&nbsp;if&nbsp;there&nbsp;are&nbsp;no&nbsp;corresponding&nbsp;values.&nbsp;By&nbsp;contrast,&nbsp;groupingBy()&nbsp;returns&nbsp;only&nbsp;keys&nbsp;that&nbsp;are&nbsp;actually&nbsp;needed.$4
616$public&nbsp;class&nbsp;Test&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Door&nbsp;implements&nbsp;AutoCloseable&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;close()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;D&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Window&nbsp;implements&nbsp;Closeable&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;close()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;W&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try(Door&nbsp;door&nbsp;=&nbsp;new&nbsp;Door();&nbsp;Window&nbsp;w&nbsp;=&nbsp;new&nbsp;Window();)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;T&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;E&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;F&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;}&nbsp;}$C.&nbsp;The&nbsp;exception&nbsp;inside&nbsp;the&nbsp;try&nbsp;block&nbsp;becomes&nbsp;the&nbsp;primary&nbsp;exception&nbsp;since&nbsp;it&nbsp;is&nbsp;thrown&nbsp;first.&nbsp;Then&nbsp;two&nbsp;suppressed&nbsp;exceptions&nbsp;are&nbsp;added&nbsp;to&nbsp;it&nbsp;when&nbsp;trying&nbsp;to&nbsp;close&nbsp;the&nbsp;AutoCloseable&nbsp;resources.$6
716$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;executing&nbsp;the&nbsp;following&nbsp;application?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>import&nbsp;java.util.concurrent.*;<br/>import&nbsp;java.util.stream.*;<br/>public&nbsp;class&nbsp;PrintConstants&nbsp;{<br/>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>ExecutorService&nbsp;service&nbsp;=&nbsp;Executors.newScheduledThreadPool(10);<br/>DoubleStream.of(3.14159,2.71828)&nbsp;//&nbsp;b1<br/>.forEach(c&nbsp;-&gt;&nbsp;service.submit(&nbsp;//&nbsp;b2<br/>()&nbsp;-&gt;&nbsp;System.out.println(10*c)));&nbsp;//&nbsp;b3<br/>service.execute(()&nbsp;-&gt;&nbsp;System.out.println(&quot;Printed&quot;));&nbsp;//&nbsp;b4<br/>}<br/>}$F,&nbsp;H.&nbsp;The&nbsp;application&nbsp;compiles&nbsp;and&nbsp;does&nbsp;not&nbsp;throw&nbsp;an&nbsp;exception,&nbsp;so&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;and&nbsp;G&nbsp;are&nbsp;incorrect.&nbsp;Even&nbsp;though&nbsp;the&nbsp;stream&nbsp;is&nbsp;processed&nbsp;in&nbsp;sequential&nbsp;order,&nbsp;the&nbsp;tasks&nbsp;are&nbsp;submitted&nbsp;to&nbsp;a&nbsp;thread&nbsp;executor,&nbsp;which&nbsp;may&nbsp;complete&nbsp;the&nbsp;tasks&nbsp;in&nbsp;any&nbsp;order.&nbsp;Therefore,&nbsp;the&nbsp;output&nbsp;cannot&nbsp;be&nbsp;determined&nbsp;ahead&nbsp;of&nbsp;time&nbsp;and&nbsp;F&nbsp;is&nbsp;correct,&nbsp;making&nbsp;A&nbsp;incorrect.&nbsp;Finally,&nbsp;the&nbsp;thread&nbsp;executor&nbsp;is&nbsp;never&nbsp;shut&nbsp;down;&nbsp;therefore&nbsp;the&nbsp;code&nbsp;will&nbsp;run&nbsp;but&nbsp;it&nbsp;will&nbsp;never&nbsp;terminate,&nbsp;making&nbsp;H&nbsp;also&nbsp;correct.$7
117$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>1:&nbsp;public&nbsp;enum&nbsp;AnimalClasses&nbsp;{<br/>2:&nbsp;MAMMAL(true),&nbsp;FISH(Boolean.FALSE),&nbsp;BIRD(false),<br/>3:&nbsp;REPTILE(false),&nbsp;AMPHIBIAN(false),&nbsp;INVERTEBRATE(false)<br/>4:&nbsp;boolean&nbsp;hasHair;<br/>5:&nbsp;public&nbsp;AnimalClasses(boolean&nbsp;hasHair)&nbsp;{<br/>6:&nbsp;this.hasHair&nbsp;=&nbsp;hasHair;<br/>7:&nbsp;}<br/>8:&nbsp;public&nbsp;boolean&nbsp;hasHair()&nbsp;{<br/>9:&nbsp;return&nbsp;hasHair;<br/>10:&nbsp;}<br/>11:&nbsp;public&nbsp;void&nbsp;giveWig()&nbsp;{<br/>12:&nbsp;hasHair&nbsp;=&nbsp;true;<br/>13:&nbsp;}&nbsp;}$B,&nbsp;C.&nbsp;Enums&nbsp;are&nbsp;required&nbsp;to&nbsp;have&nbsp;a&nbsp;semicolon&nbsp;after&nbsp;the&nbsp;list&nbsp;of&nbsp;values&nbsp;if&nbsp;there&nbsp;is&nbsp;anything&nbsp;else&nbsp;in&nbsp;the&nbsp;enum.&nbsp;Don’t&nbsp;worry;&nbsp;you&nbsp;won’t&nbsp;be&nbsp;expected&nbsp;to&nbsp;track&nbsp;down&nbsp;missing&nbsp;semicolons&nbsp;on&nbsp;the&nbsp;whole&nbsp;exam—only&nbsp;on&nbsp;enum&nbsp;questions.&nbsp;Enums&nbsp;are&nbsp;not&nbsp;allowed&nbsp;to&nbsp;have&nbsp;a&nbsp;public&nbsp;constructor.$1
217$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;are&nbsp;properties&nbsp;of&nbsp;classes&nbsp;that&nbsp;are&nbsp;properly&nbsp;encapsulated&nbsp;as&nbsp;a&nbsp;JavaBean?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$B,&nbsp;C,&nbsp;F.&nbsp;Options&nbsp;B,&nbsp;C,&nbsp;and&nbsp;F&nbsp;are&nbsp;each&nbsp;correct&nbsp;statements&nbsp;about&nbsp;JavaBean&nbsp;encapsulation.A&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;that&nbsp;is&nbsp;a&nbsp;property&nbsp;of&nbsp;the&nbsp;immutable&nbsp;object&nbsp;pattern,&nbsp;not&nbsp;encapsulation.&nbsp;D&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;there&nbsp;is&nbsp;no&nbsp;such&nbsp;JavaBean&nbsp;interface&nbsp;defined&nbsp;in&nbsp;the&nbsp;Java&nbsp;API.&nbsp;Finally,&nbsp;E&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;handling&nbsp;instantiation&nbsp;is&nbsp;not&nbsp;part&nbsp;of&nbsp;encapsulation.$2
317$Which&nbsp;two&nbsp;options&nbsp;can&nbsp;fill&nbsp;in&nbsp;the&nbsp;blanks&nbsp;to&nbsp;make&nbsp;this&nbsp;code&nbsp;compile?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>1:&nbsp;public&nbsp;class&nbsp;Generic________&nbsp;{<br/>2:&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>3:&nbsp;Generic&lt;String&gt;&nbsp;g&nbsp;=&nbsp;new&nbsp;Generic_______();<br/>4:&nbsp;Generic&lt;Object&gt;&nbsp;g2&nbsp;=&nbsp;new&nbsp;Generic();<br/>5:&nbsp;}<br/>6:&nbsp;}<br/>$B,&nbsp;D.&nbsp;Line&nbsp;1&nbsp;is&nbsp;a&nbsp;generic&nbsp;class&nbsp;that&nbsp;requires&nbsp;specifying&nbsp;a&nbsp;name&nbsp;for&nbsp;the&nbsp;type.&nbsp;Options&nbsp;A&nbsp;and&nbsp;C&nbsp;are&nbsp;incorrect&nbsp;because&nbsp;no&nbsp;type&nbsp;is&nbsp;specified.&nbsp;Line&nbsp;3&nbsp;tries&nbsp;to&nbsp;use&nbsp;the&nbsp;diamond&nbsp;operator&nbsp;to&nbsp;instantiate&nbsp;the&nbsp;class.&nbsp;Option&nbsp;E&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;T&nbsp;is&nbsp;not&nbsp;a&nbsp;class&nbsp;and&nbsp;certainly&nbsp;not&nbsp;one&nbsp;compatible&nbsp;with&nbsp;String.&nbsp;Option&nbsp;F&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;a&nbsp;wildcard&nbsp;cannot&nbsp;be&nbsp;specified&nbsp;on&nbsp;the&nbsp;right&nbsp;side&nbsp;when&nbsp;instantiating&nbsp;an&nbsp;object.$3
417$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;this&nbsp;code?<br/>UnaryOperator&lt;Integer&gt;&nbsp;u&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;x&nbsp;*&nbsp;x;$E.&nbsp;A&nbsp;UnaryOperator&nbsp;is&nbsp;a&nbsp;special&nbsp;type&nbsp;of&nbsp;function&nbsp;where&nbsp;the&nbsp;parameter&nbsp;and&nbsp;return&nbsp;type&nbsp;are&nbsp;the&nbsp;same.&nbsp;Therefore,&nbsp;option&nbsp;E&nbsp;is&nbsp;correct.&nbsp;Notice&nbsp;that&nbsp;other&nbsp;options&nbsp;don’t&nbsp;even&nbsp;compile&nbsp;because&nbsp;they&nbsp;have&nbsp;the&nbsp;wrong&nbsp;number&nbsp;of&nbsp;generic&nbsp;types&nbsp;for&nbsp;the&nbsp;functional&nbsp;interface&nbsp;provided.$4
617$Fill&nbsp;in&nbsp;the&nbsp;blank:&nbsp;A&nbsp;class&nbsp;that&nbsp;implements&nbsp;_________________&nbsp;may&nbsp;be&nbsp;in&nbsp;a&nbsp;try-with-resource<br/>statement.&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$A,&nbsp;B.&nbsp;Closeable&nbsp;was&nbsp;the&nbsp;original&nbsp;interface&nbsp;for&nbsp;IO&nbsp;classes.&nbsp;AutoCloseable&nbsp;was&nbsp;added&nbsp;in&nbsp;Java&nbsp;7&nbsp;along&nbsp;with&nbsp;try-with-resources.&nbsp;Closeable&nbsp;extends&nbsp;AutoCloseable&nbsp;for&nbsp;backward&nbsp;compatibility.$6
717$Assuming&nbsp;100&nbsp;milliseconds&nbsp;is&nbsp;enough&nbsp;time&nbsp;for&nbsp;the&nbsp;tasks&nbsp;submitted&nbsp;to&nbsp;the&nbsp;thread&nbsp;executor&nbsp;to<br/>complete,&nbsp;what&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;executing&nbsp;the&nbsp;following&nbsp;program?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>import&nbsp;java.util.concurrent.*;<br/>public&nbsp;class&nbsp;SheepManager&nbsp;{<br/>private&nbsp;static&nbsp;AtomicInteger&nbsp;sheepCount1&nbsp;=&nbsp;new&nbsp;AtomicInteger(0);&nbsp;//&nbsp;w1<br/>private&nbsp;static&nbsp;int&nbsp;sheepCount2&nbsp;=&nbsp;0;<br/>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;InterruptedException&nbsp;{<br/>ExecutorService&nbsp;service&nbsp;=&nbsp;null;<br/>try&nbsp;{<br/>service&nbsp;=&nbsp;Executors.newSingleThreadExecutor();&nbsp;//&nbsp;w2<br/>for(int&nbsp;i=0;&nbsp;i&lt;100;&nbsp;i++)<br/>service.execute(()&nbsp;-&gt;<br/>{sheepCount1.getAndIncrement();&nbsp;sheepCount2++;});&nbsp;//&nbsp;w3<br/>Thread.sleep(100);<br/>System.out.println(sheepCount1+&quot;&nbsp;&quot;+sheepCount2);<br/>}&nbsp;finally&nbsp;{<br/>if(service&nbsp;!=&nbsp;null)&nbsp;service.shutdown();<br/>}<br/>}$B.&nbsp;The&nbsp;code&nbsp;compiles&nbsp;and&nbsp;runs&nbsp;without&nbsp;issue,&nbsp;so&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;and&nbsp;G&nbsp;are&nbsp;incorrect.&nbsp;The&nbsp;key&nbsp;aspect&nbsp;to&nbsp;notice&nbsp;in&nbsp;the&nbsp;code&nbsp;is&nbsp;that&nbsp;a&nbsp;single-thread&nbsp;executor&nbsp;is&nbsp;used,&nbsp;meaning&nbsp;that&nbsp;no&nbsp;task&nbsp;will&nbsp;be&nbsp;executed&nbsp;concurrently.&nbsp;Therefore,&nbsp;the&nbsp;results&nbsp;are&nbsp;valid&nbsp;and&nbsp;predictable&nbsp;with&nbsp;100&nbsp;100&nbsp;being&nbsp;the&nbsp;output,&nbsp;and&nbsp;B&nbsp;is&nbsp;the&nbsp;correct&nbsp;answer.&nbsp;If&nbsp;a&nbsp;pooled&nbsp;thread&nbsp;executor&nbsp;was&nbsp;used&nbsp;with&nbsp;at&nbsp;least&nbsp;two&nbsp;threads,&nbsp;then&nbsp;the&nbsp;sheepCount2++&nbsp;operations&nbsp;could&nbsp;overwrite&nbsp;each&nbsp;other,&nbsp;making&nbsp;the&nbsp;second&nbsp;value&nbsp;indeterminate&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;program.&nbsp;In&nbsp;this&nbsp;case,&nbsp;C&nbsp;would&nbsp;be&nbsp;the&nbsp;correct&nbsp;answer.$7
118$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>public&nbsp;class&nbsp;Swimmer&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;enum&nbsp;AnimalClasses&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAMMAL,&nbsp;FISH&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;hasFins()&nbsp;{&nbsp;return&nbsp;true;&nbsp;}},<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BIRD,&nbsp;REPTILE,&nbsp;AMPHIBIAN,&nbsp;INVERTEBRATE;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;boolean&nbsp;hasFins();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(AnimalClasses.FISH);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(AnimalClasses.FISH.ordinal());<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(AnimalClasses.FISH.hasFins());<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(AnimalClasses.BIRD.hasFins());<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}$G.&nbsp;This&nbsp;question&nbsp;appears&nbsp;to&nbsp;be&nbsp;about&nbsp;enums&nbsp;but&nbsp;is&nbsp;really&nbsp;about&nbsp;abstract&nbsp;methods.&nbsp;Just&nbsp;as&nbsp;an&nbsp;abstract&nbsp;superclass&nbsp;requires&nbsp;concrete&nbsp;subclasses&nbsp;to&nbsp;have&nbsp;an&nbsp;implementation,&nbsp;abstract&nbsp;enum&nbsp;methods&nbsp;require&nbsp;each&nbsp;enum&nbsp;type&nbsp;to&nbsp;implement&nbsp;the&nbsp;method.$1
218$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;statements&nbsp;about&nbsp;inheritance&nbsp;and&nbsp;object&nbsp;composition&nbsp;are&nbsp;correct?<br/>(Choose&nbsp;all&nbsp;that&nbsp;apply.)$A,&nbsp;B,&nbsp;E.&nbsp;A&nbsp;is&nbsp;correct,&nbsp;and&nbsp;it&nbsp;is&nbsp;one&nbsp;of&nbsp;the&nbsp;reasons&nbsp;to&nbsp;prefer&nbsp;class&nbsp;inheritance&nbsp;over&nbsp;object&nbsp;composition.&nbsp;B&nbsp;is&nbsp;also&nbsp;correct,&nbsp;since&nbsp;object&nbsp;composition&nbsp;tends&nbsp;to&nbsp;lead&nbsp;to&nbsp;classes&nbsp;that&nbsp;are&nbsp;easier&nbsp;to&nbsp;reference,&nbsp;as&nbsp;they&nbsp;don&#x2019;t&nbsp;require&nbsp;knowledge&nbsp;of&nbsp;any&nbsp;parent&nbsp;classes.&nbsp;C&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;inheritance&nbsp;tends&nbsp;to&nbsp;use&nbsp;the&nbsp;is-a&nbsp;principle,&nbsp;whereas&nbsp;object&nbsp;composition&nbsp;relies&nbsp;on&nbsp;the&nbsp;has-a&nbsp;principle.&nbsp;D&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;this&nbsp;is&nbsp;a&nbsp;statement&nbsp;about&nbsp;inheritance,&nbsp;not&nbsp;object&nbsp;composition.&nbsp;E&nbsp;is&nbsp;correct,&nbsp;as&nbsp;object&nbsp;composition&nbsp;has&nbsp;no&nbsp;notion&nbsp;of&nbsp;inheritance&nbsp;and&nbsp;variables&nbsp;must&nbsp;be&nbsp;exposed&nbsp;publically&nbsp;if&nbsp;they&nbsp;are&nbsp;to&nbsp;be&nbsp;used&nbsp;by&nbsp;other&nbsp;classes&nbsp;in&nbsp;different&nbsp;packages.&nbsp;F&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;neither&nbsp;are&nbsp;always&nbsp;the&nbsp;right&nbsp;answer.&nbsp;There&nbsp;are&nbsp;situations&nbsp;where&nbsp;inheritance&nbsp;is&nbsp;more&nbsp;appropriate,&nbsp;and&nbsp;situations&nbsp;where&nbsp;object&nbsp;composition&nbsp;is&nbsp;more&nbsp;appropriate.$2
318$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;lines&nbsp;can&nbsp;be&nbsp;inserted&nbsp;to&nbsp;make&nbsp;the&nbsp;code&nbsp;compile?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>class&nbsp;A&nbsp;{}<br/>class&nbsp;B&nbsp;extends&nbsp;A&nbsp;{}<br/>class&nbsp;C&nbsp;extends&nbsp;B&nbsp;{}<br/>class&nbsp;D&lt;C&gt;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;INSERT&nbsp;CODE&nbsp;HERE<br/>}$A,&nbsp;B.&nbsp;C&nbsp;is&nbsp;both&nbsp;a&nbsp;class&nbsp;and&nbsp;a&nbsp;type&nbsp;parameter.&nbsp;This&nbsp;means&nbsp;that&nbsp;within&nbsp;the&nbsp;class&nbsp;D,&nbsp;when&nbsp;we&nbsp;refer&nbsp;to&nbsp;C,&nbsp;it&nbsp;uses&nbsp;the&nbsp;type&nbsp;parameter.&nbsp;All&nbsp;of&nbsp;the&nbsp;choices&nbsp;that&nbsp;mention&nbsp;class&nbsp;C&nbsp;are&nbsp;incorrect&nbsp;because&nbsp;it&nbsp;no&nbsp;longer&nbsp;means&nbsp;the&nbsp;class&nbsp;C.$3
418$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following?<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;DoubleStream&nbsp;s&nbsp;=&nbsp;DoubleStream.of(1.2,&nbsp;2.4);<br/>&nbsp;&nbsp;&nbsp;&nbsp;s.peek(System.out::println).filter(x&nbsp;-&gt;&nbsp;x&nbsp;&gt;&nbsp;2).count();$D.&nbsp;The&nbsp;terminal&nbsp;operation&nbsp;is&nbsp;count().&nbsp;Since&nbsp;there&nbsp;is&nbsp;a&nbsp;terminal&nbsp;operation,&nbsp;the&nbsp;intermediate&nbsp;operations&nbsp;run.&nbsp;The&nbsp;peek()&nbsp;operation&nbsp;comes&nbsp;before&nbsp;the&nbsp;filter,&nbsp;so&nbsp;both&nbsp;numbers&nbsp;are&nbsp;printed.&nbsp;The&nbsp;count&nbsp;happens&nbsp;to&nbsp;be&nbsp;1&nbsp;since&nbsp;the&nbsp;other&nbsp;number&nbsp;is&nbsp;filtered.&nbsp;However,&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;stream&nbsp;pipeline&nbsp;isn&#x2019;t&nbsp;stored&nbsp;in&nbsp;a&nbsp;variable,&nbsp;and&nbsp;that&nbsp;result&nbsp;is&nbsp;ignored.$4
618$Which&nbsp;pairs&nbsp;fill&nbsp;in&nbsp;the&nbsp;blanks?&nbsp;The&nbsp;close()&nbsp;method&nbsp;is&nbsp;not&nbsp;allowed&nbsp;to&nbsp;throw&nbsp;a(n)&nbsp;_________________&nbsp;in&nbsp;a&nbsp;class&nbsp;that&nbsp;implements&nbsp;_________________.&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$B.&nbsp;The&nbsp;main&nbsp;difference&nbsp;between&nbsp;AutoCloseable&nbsp;and&nbsp;Closeable&nbsp;is&nbsp;that&nbsp;AutoCloseable&nbsp;has&nbsp;Exception&nbsp;in&nbsp;the&nbsp;signature&nbsp;and&nbsp;Closeable&nbsp;has&nbsp;only&nbsp;IOException&nbsp;in&nbsp;the&nbsp;signature.&nbsp;Since&nbsp;IllegalStateException&nbsp;is&nbsp;a&nbsp;runtime&nbsp;exception,&nbsp;it&nbsp;can&nbsp;be&nbsp;thrown&nbsp;by&nbsp;any&nbsp;method.$6
718$import&nbsp;java.util.concurrent.*;<br/>import&nbsp;java.util.stream.*;<br/>public&nbsp;class&nbsp;StockRoomTracker&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;await(CyclicBarrier&nbsp;cb)&nbsp;{&nbsp;//&nbsp;j1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cb.await();&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;|<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BrokenBarrierException&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Handle&nbsp;exception<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CyclicBarrier&nbsp;cb&nbsp;=&nbsp;new&nbsp;CyclicBarrier(10,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()&nbsp;-&gt;&nbsp;System.out.println(&quot;Stock&nbsp;Room&nbsp;Full!&quot;));&nbsp;//&nbsp;j2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IntStream.iterate(1,&nbsp;i&nbsp;-&gt;&nbsp;1).limit(9)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.parallel().forEach(i&nbsp;-&gt;&nbsp;await(cb));&nbsp;//&nbsp;j3<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}$F.&nbsp;The&nbsp;code&nbsp;compiles&nbsp;without&nbsp;issue,&nbsp;so&nbsp;B,&nbsp;C,&nbsp;and&nbsp;D&nbsp;are&nbsp;incorrect.&nbsp;The&nbsp;limit&nbsp;on&nbsp;the&nbsp;cyclic&nbsp;barrier&nbsp;is&nbsp;10,&nbsp;but&nbsp;the&nbsp;stream&nbsp;can&nbsp;generate&nbsp;only&nbsp;up&nbsp;to&nbsp;9&nbsp;threads&nbsp;that&nbsp;reach&nbsp;the&nbsp;barrier;&nbsp;therefore&nbsp;the&nbsp;limit&nbsp;can&nbsp;never&nbsp;be&nbsp;reached,&nbsp;and&nbsp;F&nbsp;is&nbsp;the&nbsp;correct&nbsp;answer,&nbsp;making&nbsp;A&nbsp;and&nbsp;E&nbsp;incorrect.&nbsp;Note&nbsp;that&nbsp;even&nbsp;if&nbsp;the&nbsp;limit(9)&nbsp;statement&nbsp;was&nbsp;changed&nbsp;to&nbsp;limit(10),&nbsp;the&nbsp;program&nbsp;could&nbsp;still&nbsp;hang,&nbsp;since&nbsp;the&nbsp;JVM&nbsp;might&nbsp;not&nbsp;allocate&nbsp;10&nbsp;threads&nbsp;to&nbsp;the&nbsp;parallel&nbsp;stream.$7
119$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;can&nbsp;be&nbsp;inserted&nbsp;to&nbsp;override&nbsp;the&nbsp;superclass&nbsp;method?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/><br/>public&nbsp;class&nbsp;LearnToWalk&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;toddle()&nbsp;{}<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;BabyRhino&nbsp;extends&nbsp;LearnToWalk&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;INSERT&nbsp;CODE&nbsp;HERE<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}$A,&nbsp;C.&nbsp;An&nbsp;override&nbsp;must&nbsp;have&nbsp;the&nbsp;same&nbsp;method&nbsp;signature.&nbsp;A&nbsp;and&nbsp;C&nbsp;both&nbsp;do.&nbsp;F&nbsp;is&nbsp;an&nbsp;overload&nbsp;because&nbsp;it&nbsp;has&nbsp;a&nbsp;different&nbsp;parameter&nbsp;list.&nbsp;E&nbsp;does&nbsp;not&nbsp;compile&nbsp;because&nbsp;it&nbsp;throws&nbsp;a&nbsp;checked&nbsp;exception&nbsp;not&nbsp;declared&nbsp;in&nbsp;the&nbsp;superclass.&nbsp;D&nbsp;compiles&nbsp;but&nbsp;is&nbsp;not&nbsp;an&nbsp;override&nbsp;because&nbsp;it&nbsp;is&nbsp;static.&nbsp;B&nbsp;has&nbsp;a&nbsp;different&nbsp;method&nbsp;name,&nbsp;so&nbsp;it&nbsp;is&nbsp;not&nbsp;even&nbsp;an&nbsp;overload.$1
219$Which&nbsp;three&nbsp;scenarios&nbsp;would&nbsp;best&nbsp;benefit&nbsp;from&nbsp;using&nbsp;a&nbsp;singleton&nbsp;pattern?&nbsp;(Choose&nbsp;all&nbsp;three.)$B,&nbsp;D,&nbsp;E.&nbsp;A&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;that&nbsp;is&nbsp;a&nbsp;property&nbsp;of&nbsp;the&nbsp;immutable&nbsp;object&nbsp;pattern.&nbsp;B&nbsp;is&nbsp;correct,&nbsp;as&nbsp;caching&nbsp;data&nbsp;is&nbsp;one&nbsp;of&nbsp;the&nbsp;most&nbsp;common&nbsp;uses&nbsp;of&nbsp;the&nbsp;singleton&nbsp;pattern.&nbsp;While&nbsp;the&nbsp;singleton&nbsp;pattern&nbsp;may&nbsp;use&nbsp;lazy&nbsp;instantiation,&nbsp;it&nbsp;is&nbsp;not&nbsp;used&nbsp;to&nbsp;ensure&nbsp;that&nbsp;objects&nbsp;are&nbsp;lazily&nbsp;instantiated,&nbsp;so&nbsp;C&nbsp;is&nbsp;incorrect.&nbsp;D&nbsp;is&nbsp;correct,&nbsp;as&nbsp;we&nbsp;only&nbsp;want&nbsp;one&nbsp;class&nbsp;writing&nbsp;to&nbsp;a&nbsp;log&nbsp;file&nbsp;at&nbsp;once.E&nbsp;is&nbsp;also&nbsp;correct,&nbsp;as&nbsp;managing&nbsp;application-wide&nbsp;configuration&nbsp;data&nbsp;is&nbsp;another&nbsp;very&nbsp;common&nbsp;use&nbsp;of&nbsp;the&nbsp;singleton&nbsp;pattern.&nbsp;F&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;we&nbsp;only&nbsp;want&nbsp;one&nbsp;instance&nbsp;of&nbsp;a&nbsp;static&nbsp;object&nbsp;created&nbsp;when&nbsp;using&nbsp;the&nbsp;singleton&nbsp;pattern.$2
319$Which&nbsp;options&nbsp;are&nbsp;true&nbsp;of&nbsp;the&nbsp;following&nbsp;code?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/>3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________&lt;Integer&gt;&nbsp;q&nbsp;=&nbsp;new&nbsp;LinkedList&lt;&gt;();<br/>4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.add(10);<br/>5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.add(12);<br/>6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.remove(1);<br/>7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(q);$A,&nbsp;D.&nbsp;A&nbsp;LinkedList&nbsp;implements&nbsp;both&nbsp;List&nbsp;and&nbsp;Queue.&nbsp;The&nbsp;List&nbsp;interface&nbsp;has&nbsp;a&nbsp;method&nbsp;to&nbsp;remove&nbsp;by&nbsp;index.&nbsp;Since&nbsp;this&nbsp;method&nbsp;exists,&nbsp;Java&nbsp;does&nbsp;not&nbsp;autobox&nbsp;to&nbsp;call&nbsp;the&nbsp;other&nbsp;method.&nbsp;Queue&nbsp;has&nbsp;only&nbsp;the&nbsp;remove&nbsp;by&nbsp;object&nbsp;method,&nbsp;so&nbsp;Java&nbsp;does&nbsp;autobox&nbsp;there.&nbsp;Since&nbsp;the&nbsp;number&nbsp;1&nbsp;is&nbsp;not&nbsp;in&nbsp;the&nbsp;list,&nbsp;Java&nbsp;does&nbsp;not&nbsp;remove&nbsp;anything&nbsp;for&nbsp;the&nbsp;Queue.$3
419$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;return&nbsp;primitives?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$A,&nbsp;C,&nbsp;E.&nbsp;The&nbsp;three&nbsp;common&nbsp;types&nbsp;of&nbsp;double,&nbsp;int&nbsp;and,&nbsp;long&nbsp;have&nbsp;dedicated&nbsp;supplier&nbsp;classes.&nbsp;The&nbsp;only&nbsp;primitive&nbsp;functional&nbsp;interface&nbsp;that&nbsp;does&nbsp;not&nbsp;involve&nbsp;one&nbsp;of&nbsp;those&nbsp;three&nbsp;types&nbsp;is&nbsp;BooleanSupplier.$4
619$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;cannot&nbsp;fill&nbsp;in&nbsp;the&nbsp;blank?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/><br/>public&nbsp;void&nbsp;read()&nbsp;throws&nbsp;SQLException&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readFromDatabase();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(_________________&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>private&nbsp;void&nbsp;readFromDatabase()&nbsp;throws&nbsp;SQLException&nbsp;{&nbsp;}$D.&nbsp;Choice&nbsp;A&nbsp;is&nbsp;allowed&nbsp;because&nbsp;Java&nbsp;7&nbsp;and&nbsp;later&nbsp;&#x201c;translates&#x201d;&nbsp;Exception&nbsp;in&nbsp;a&nbsp;catch&nbsp;block&nbsp;to&nbsp;the&nbsp;correct&nbsp;one.&nbsp;Choices&nbsp;C&nbsp;and&nbsp;E&nbsp;are&nbsp;allowed&nbsp;because&nbsp;they&nbsp;actually&nbsp;catch&nbsp;a&nbsp;SQLException.&nbsp;Choice&nbsp;D&nbsp;is&nbsp;not&nbsp;allowed&nbsp;because&nbsp;there&nbsp;is&nbsp;no&nbsp;IOException&nbsp;declared.&nbsp;Choice&nbsp;B&nbsp;is&nbsp;allowed&nbsp;because&nbsp;a&nbsp;method&nbsp;does&nbsp;not&nbsp;have&nbsp;to&nbsp;handle&nbsp;an&nbsp;exception&nbsp;if&nbsp;it&nbsp;declares&nbsp;it.$6
719$What&nbsp;statements&nbsp;about&nbsp;the&nbsp;following&nbsp;class&nbsp;definition&nbsp;are&nbsp;true?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/><br/>public&nbsp;class&nbsp;TicketManager&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;TicketManager()&nbsp;{&nbsp;super();&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;TicketManager&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;synchronized&nbsp;TicketManager&nbsp;getInstance()&nbsp;{&nbsp;//&nbsp;k1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;instance&nbsp;=&nbsp;new&nbsp;TicketManager();&nbsp;//&nbsp;k2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;tickets;<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getTicketCount()&nbsp;{&nbsp;return&nbsp;tickets;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;makeTicketsAvailable(int&nbsp;value)&nbsp;{&nbsp;tickets&nbsp;+=&nbsp;value;&nbsp;}&nbsp;//&nbsp;k3<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;sellTickets(int&nbsp;value)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(this)&nbsp;{&nbsp;//&nbsp;k4<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tickets&nbsp;-=&nbsp;value;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}$A,&nbsp;F.&nbsp;The&nbsp;class&nbsp;compiles&nbsp;without&nbsp;issue&nbsp;so&nbsp;A&nbsp;is&nbsp;correct,&nbsp;and&nbsp;B&nbsp;and&nbsp;C&nbsp;are&nbsp;incorrect.&nbsp;The<br/>synchronized&nbsp;object&nbsp;on&nbsp;line&nbsp;k1&nbsp;is&nbsp;TicketManager.class,&nbsp;while&nbsp;the&nbsp;synchronized&nbsp;object<br/>on&nbsp;line&nbsp;k4&nbsp;is&nbsp;the&nbsp;instance&nbsp;of&nbsp;TicketManager.&nbsp;The&nbsp;class&nbsp;is&nbsp;not&nbsp;thread-safe&nbsp;because<br/>the&nbsp;makeTicketsAvailable()&nbsp;method&nbsp;is&nbsp;not&nbsp;synchronized,&nbsp;and&nbsp;E&nbsp;is&nbsp;incorrect.&nbsp;One<br/>thread&nbsp;could&nbsp;call&nbsp;sellTickets()&nbsp;while&nbsp;another&nbsp;thread&nbsp;has&nbsp;unblocked&nbsp;accessed&nbsp;to<br/>makeTicketsAvailable(),&nbsp;causing&nbsp;an&nbsp;invalid&nbsp;number&nbsp;of&nbsp;tickets&nbsp;to&nbsp;be&nbsp;reached&nbsp;as&nbsp;part<br/>of&nbsp;a&nbsp;race&nbsp;condition.&nbsp;Finally,&nbsp;F&nbsp;is&nbsp;correct&nbsp;because&nbsp;the&nbsp;class&nbsp;synchronizes&nbsp;using&nbsp;a&nbsp;static<br/>getInstance()&nbsp;method,&nbsp;preventing&nbsp;more&nbsp;than&nbsp;one&nbsp;instance&nbsp;from&nbsp;being&nbsp;created.$7
120$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?<br/><br/>public&nbsp;class&nbsp;FourLegged&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;walk&nbsp;=&nbsp;&quot;walk,&quot;;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;BabyRhino&nbsp;extends&nbsp;FourLegged&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;walk&nbsp;=&nbsp;&quot;toddle,&quot;;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FourLegged&nbsp;f&nbsp;=&nbsp;new&nbsp;BabyRhino();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BabyRhino&nbsp;b&nbsp;=&nbsp;new&nbsp;BabyRhino();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(f.walk);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(b.walk);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}$C.&nbsp;Both&nbsp;objects&nbsp;are&nbsp;BabyRhino&nbsp;objects.&nbsp;Virtual&nbsp;method&nbsp;invocation&nbsp;says&nbsp;that&nbsp;the&nbsp;subclass&nbsp;method&nbsp;gets&nbsp;called&nbsp;at&nbsp;runtime&nbsp;rather&nbsp;than&nbsp;the&nbsp;type&nbsp;in&nbsp;the&nbsp;variable&nbsp;reference.&nbsp;However,&nbsp;we&nbsp;are&nbsp;not&nbsp;calling&nbsp;methods&nbsp;here.&nbsp;We&nbsp;are&nbsp;referring&nbsp;to&nbsp;instance&nbsp;variables.&nbsp;With&nbsp;instance&nbsp;variables,&nbsp;the&nbsp;reference&nbsp;type&nbsp;does&nbsp;matter.$1
220$Choose&nbsp;the&nbsp;correct&nbsp;statement&nbsp;about&nbsp;the&nbsp;following&nbsp;code:<br/>1:&nbsp;public&nbsp;interface&nbsp;CanFly&nbsp;{<br/>2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;fly();<br/>3:&nbsp;}<br/>4:&nbsp;interface&nbsp;HasWings&nbsp;{<br/>5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Object&nbsp;getWingSpan();<br/>6:&nbsp;}<br/>7:&nbsp;abstract&nbsp;class&nbsp;Falcon&nbsp;implements&nbsp;CanFly,&nbsp;HasWings&nbsp;{<br/>8:&nbsp;}$A.&nbsp;Although&nbsp;the&nbsp;definition&nbsp;of&nbsp;methods&nbsp;on&nbsp;lines&nbsp;2&nbsp;and&nbsp;5&nbsp;vary,&nbsp;both&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;public&nbsp;abstract&nbsp;by&nbsp;the&nbsp;compiler.&nbsp;Line&nbsp;4&nbsp;is&nbsp;fine,&nbsp;because&nbsp;an&nbsp;interface&nbsp;can&nbsp;have&nbsp;public&nbsp;or&nbsp;default&nbsp;access.&nbsp;Finally,&nbsp;the&nbsp;class&nbsp;Falcon&nbsp;doesn&#x2019;t&nbsp;need&nbsp;to&nbsp;implement&nbsp;the&nbsp;interface&nbsp;methods&nbsp;because&nbsp;it&nbsp;is&nbsp;marked&nbsp;as&nbsp;abstract.&nbsp;Therefore,&nbsp;the&nbsp;code&nbsp;will&nbsp;compile&nbsp;without&nbsp;issue.$2
320$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?<br/><br/>4:&nbsp;Map&nbsp;m&nbsp;=&nbsp;new&nbsp;HashMap();<br/>5:&nbsp;m.put(123,&nbsp;&quot;456&quot;);<br/>6:&nbsp;m.put(&quot;abc&quot;,&nbsp;&quot;def&quot;);<br/>7:&nbsp;System.out.println(m.contains(&quot;123&quot;));$E.&nbsp;This&nbsp;question&nbsp;looks&nbsp;like&nbsp;it&nbsp;is&nbsp;about&nbsp;generics,&nbsp;but&nbsp;it&#x2019;s&nbsp;not.&nbsp;It&nbsp;is&nbsp;trying&nbsp;to&nbsp;see&nbsp;if&nbsp;you&nbsp;noticed&nbsp;that&nbsp;Map&nbsp;does&nbsp;not&nbsp;have&nbsp;a&nbsp;contains()&nbsp;method.&nbsp;It&nbsp;has&nbsp;containsKey()&nbsp;and&nbsp;containsValue()&nbsp;instead.&nbsp;If&nbsp;containsKey()&nbsp;was&nbsp;called,&nbsp;the&nbsp;answer&nbsp;would&nbsp;be&nbsp;false&nbsp;because&nbsp;the&nbsp;123&nbsp;in&nbsp;the&nbsp;list&nbsp;is&nbsp;an&nbsp;Integer&nbsp;rather&nbsp;than&nbsp;a&nbsp;String.$3
420$What&nbsp;is&nbsp;the&nbsp;simplest&nbsp;way&nbsp;of&nbsp;rewriting&nbsp;this&nbsp;code?<br/><br/>List&lt;Integer&gt;&nbsp;l&nbsp;=&nbsp;IntStream.range(1,&nbsp;6)<br/>&nbsp;&nbsp;&nbsp;&nbsp;.mapToObj(i&nbsp;-&gt;&nbsp;i).collect(Collectors.toList());<br/>&nbsp;&nbsp;&nbsp;&nbsp;l.forEach(System.out::println);$B.&nbsp;Both&nbsp;lists&nbsp;and&nbsp;streams&nbsp;have&nbsp;forEach()&nbsp;methods.&nbsp;There&nbsp;is&nbsp;no&nbsp;reason&nbsp;to&nbsp;collect&nbsp;into&nbsp;a&nbsp;list&nbsp;just&nbsp;to&nbsp;loop&nbsp;through&nbsp;it.$4
620$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;is&nbsp;true&nbsp;when&nbsp;creating&nbsp;your&nbsp;own&nbsp;exception&nbsp;class?$E.&nbsp;You&nbsp;can&nbsp;create&nbsp;checked&nbsp;or&nbsp;unchecked&nbsp;exceptions.&nbsp;The&nbsp;default&nbsp;constructor&nbsp;is&nbsp;used&nbsp;if&nbsp;one&nbsp;is&nbsp;not&nbsp;supplied.&nbsp;There&nbsp;is&nbsp;no&nbsp;requirement&nbsp;to&nbsp;implement&nbsp;specific&nbsp;methods.$6
720$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;properties&nbsp;of&nbsp;concurrency&nbsp;are&nbsp;true?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)$A,&nbsp;D.&nbsp;By&nbsp;itself,&nbsp;concurrency&nbsp;does&nbsp;not&nbsp;guarantee&nbsp;which&nbsp;task&nbsp;will&nbsp;be&nbsp;completed&nbsp;first,&nbsp;so&nbsp;A&nbsp;is&nbsp;correct.&nbsp;Furthermore,&nbsp;applications&nbsp;with&nbsp;numerous&nbsp;resource&nbsp;requests&nbsp;will&nbsp;often&nbsp;be&nbsp;stuck&nbsp;waiting&nbsp;for&nbsp;a&nbsp;resource,&nbsp;which&nbsp;allows&nbsp;other&nbsp;tasks&nbsp;to&nbsp;run.&nbsp;Therefore,&nbsp;they&nbsp;tend&nbsp;to&nbsp;benefit&nbsp;more&nbsp;from&nbsp;concurrency&nbsp;than&nbsp;CPU-intensive&nbsp;tasks,&nbsp;so&nbsp;D&nbsp;is&nbsp;also&nbsp;correct.&nbsp;B&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;concurrency&nbsp;may&nbsp;in&nbsp;fact&nbsp;make&nbsp;an&nbsp;application&nbsp;slower&nbsp;if&nbsp;it&nbsp;is&nbsp;truly&nbsp;single-threaded&nbsp;in&nbsp;nature.&nbsp;Keep&nbsp;in&nbsp;mind&nbsp;that&nbsp;there&nbsp;is&nbsp;a&nbsp;cost&nbsp;associated&nbsp;with&nbsp;allocating&nbsp;additional&nbsp;memory&nbsp;and&nbsp;CPU&nbsp;time&nbsp;to&nbsp;manage&nbsp;the&nbsp;concurrent&nbsp;process.&nbsp;C&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;single-processor&nbsp;CPUs&nbsp;have&nbsp;been&nbsp;benefiting&nbsp;from&nbsp;concurrency&nbsp;for&nbsp;decades.&nbsp;Finally,&nbsp;E&nbsp;is&nbsp;incorrect;&nbsp;there&nbsp;are&nbsp;numerous&nbsp;examples&nbsp;in&nbsp;this&nbsp;chapter&nbsp;of&nbsp;concurrent&nbsp;tasks&nbsp;sharing&nbsp;memory.$7
114$Which&nbsp;is&nbsp;a&nbsp;true&nbsp;statement&nbsp;about&nbsp;the&nbsp;following&nbsp;code?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/><br/>import&nbsp;java.util.&nbsp;*;<br/>public&nbsp;class&nbsp;IsItFurry&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Chipmunk&nbsp;{&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chipmunk&nbsp;c&nbsp;=&nbsp;new&nbsp;Chipmunk();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;&lt;Chipmunk&gt;&nbsp;l&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;r&nbsp;=&nbsp;new&nbsp;Thread();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;instanceof&nbsp;Chipmunk)&nbsp;result&nbsp;+=&nbsp;1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;instanceof&nbsp;Chipmunk)&nbsp;result&nbsp;+=&nbsp;2;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;instanceof&nbsp;Chipmunk)&nbsp;result&nbsp;+=&nbsp;4;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br/>}$E.&nbsp;Code&nbsp;involving&nbsp;instanceof&nbsp;does&nbsp;not&nbsp;compile&nbsp;when&nbsp;there&nbsp;is&nbsp;no&nbsp;way&nbsp;for&nbsp;it&nbsp;to&nbsp;evaluate&nbsp;true.&nbsp;D&nbsp;not&nbsp;only&nbsp;compiles&nbsp;but&nbsp;it&nbsp;is&nbsp;always&nbsp;true.&nbsp;E&nbsp;does&nbsp;not&nbsp;compile&nbsp;because&nbsp;ArrayList&nbsp;is&nbsp;a&nbsp;concrete&nbsp;class&nbsp;that&nbsp;does&nbsp;not&nbsp;extend&nbsp;Chipmunk.&nbsp;F&nbsp;does&nbsp;compile&nbsp;because&nbsp;Runnable&nbsp;is&nbsp;an&nbsp;interface.&nbsp;In&nbsp;theory,&nbsp;someone&nbsp;could&nbsp;subclass&nbsp;Chipmunk&nbsp;and&nbsp;have&nbsp;the&nbsp;subclass&nbsp;implement&nbsp;Runnable.$1
214$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;statements&nbsp;can&nbsp;be&nbsp;inserted&nbsp;in&nbsp;the&nbsp;blank&nbsp;line&nbsp;so&nbsp;that&nbsp;the&nbsp;code&nbsp;will&nbsp;compile&nbsp;successfully?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/><br/>public&nbsp;interface&nbsp;CanHop&nbsp;{}<br/>public&nbsp;class&nbsp;Frog&nbsp;implements&nbsp;CanHop&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_______________&nbsp;frog&nbsp;=&nbsp;new&nbsp;TurtleFrog();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>public&nbsp;class&nbsp;BrazilianHornedFrog&nbsp;extends&nbsp;Frog&nbsp;{}<br/>public&nbsp;class&nbsp;TurtleFrog&nbsp;extends&nbsp;Frog&nbsp;{}$A,&nbsp;B,&nbsp;D,&nbsp;E.&nbsp;The&nbsp;blank&nbsp;can&nbsp;be&nbsp;filled&nbsp;with&nbsp;any&nbsp;class&nbsp;or&nbsp;interface&nbsp;that&nbsp;is&nbsp;a&nbsp;supertype&nbsp;of&nbsp;TurtleFrog.&nbsp;A&nbsp;is&nbsp;a&nbsp;superclass&nbsp;of&nbsp;TurtleFrog,&nbsp;and&nbsp;B&nbsp;is&nbsp;the&nbsp;same&nbsp;class,&nbsp;so&nbsp;both&nbsp;are&nbsp;correct.&nbsp;BrazilianHornedFrog&nbsp;is&nbsp;not&nbsp;a&nbsp;superclass&nbsp;of&nbsp;TurtleFrog,&nbsp;so&nbsp;C&nbsp;is&nbsp;incorrect.&nbsp;TurtleFrog&nbsp;inherits&nbsp;the&nbsp;CanHop&nbsp;interface,&nbsp;so&nbsp;D&nbsp;is&nbsp;correct.&nbsp;All&nbsp;classes&nbsp;inherit&nbsp;Object,&nbsp;so&nbsp;E&nbsp;is&nbsp;correct.&nbsp;Finally,&nbsp;Long&nbsp;is&nbsp;an&nbsp;unrelated&nbsp;class&nbsp;that&nbsp;is&nbsp;not&nbsp;a&nbsp;superclass&nbsp;of&nbsp;TurtleFrog,&nbsp;and&nbsp;it&nbsp;is&nbsp;therefore&nbsp;incorrect.$2
314$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;program?<br/><br/>import&nbsp;java.util.*;<br/>public&nbsp;class&nbsp;Sorted&nbsp;implements&nbsp;Comparable&lt;Sorted&gt;,&nbsp;Comparator&lt;Sorted&gt;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;num;<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;text;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Sorted(int&nbsp;n,&nbsp;String&nbsp;t)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.num&nbsp;=&nbsp;n;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text&nbsp;=&nbsp;t;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()&nbsp;{&nbsp;return&nbsp;&quot;&quot;&nbsp;+&nbsp;num;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;compareTo(Sorted&nbsp;s)&nbsp;{&nbsp;return&nbsp;text.compareTo(s.text);&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;compare(Sorted&nbsp;s1,&nbsp;Sorted&nbsp;s2)&nbsp;{&nbsp;return&nbsp;s1.num&nbsp;&#x2013;&nbsp;s2.num;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorted&nbsp;s1&nbsp;=&nbsp;new&nbsp;Sorted(88,&nbsp;&quot;a&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorted&nbsp;s2&nbsp;=&nbsp;new&nbsp;Sorted(55,&nbsp;&quot;b&quot;);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeSet&lt;Sorted&gt;&nbsp;t1&nbsp;=&nbsp;new&nbsp;TreeSet&lt;&gt;();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1.add(s1);&nbsp;t1.add(s2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeSet&lt;Sorted&gt;&nbsp;t2&nbsp;=&nbsp;new&nbsp;TreeSet&lt;&gt;(s1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2.add(s1);&nbsp;t2.add(s2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(t1&nbsp;+&nbsp;&quot;&nbsp;&quot;&nbsp;+&nbsp;t2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}$C.&nbsp;This&nbsp;question&nbsp;is&nbsp;hard&nbsp;because&nbsp;it&nbsp;defines&nbsp;both&nbsp;Comparable&nbsp;and&nbsp;Comparator&nbsp;on&nbsp;the&nbsp;same&nbsp;object.&nbsp;t1&nbsp;doesn&#x2019;t&nbsp;specify&nbsp;a&nbsp;Comparator&nbsp;so&nbsp;it&nbsp;uses&nbsp;the&nbsp;Comparable&nbsp;object&#x2019;s&nbsp;compareTo()&nbsp;method.&nbsp;This&nbsp;sorts&nbsp;by&nbsp;the&nbsp;text&nbsp;instance&nbsp;variable.&nbsp;t2&nbsp;did&nbsp;specify&nbsp;a&nbsp;Comparator&nbsp;when&nbsp;calling&nbsp;the&nbsp;constructor,&nbsp;so&nbsp;it&nbsp;uses&nbsp;the&nbsp;compare()&nbsp;method,&nbsp;which&nbsp;sorts&nbsp;by&nbsp;the&nbsp;int.$3
414$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;is&nbsp;true?<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;Stream&lt;Integer&gt;&nbsp;s&nbsp;=&nbsp;Stream.of(1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;IntStream&nbsp;is&nbsp;=&nbsp;s.mapToInt(x&nbsp;-&gt;&nbsp;x);<br/>&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;DoubleStream&nbsp;ds&nbsp;=&nbsp;s.mapToDouble(x&nbsp;-&gt;&nbsp;x);<br/>&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;Stream&lt;Integer&gt;&nbsp;s2&nbsp;=&nbsp;ds.mapToInt(x&nbsp;-&gt;&nbsp;x);<br/>&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;s2.forEach(System.out::print);$D.&nbsp;Line&nbsp;4&nbsp;should&nbsp;obviously&nbsp;look&nbsp;OK.&nbsp;It&nbsp;creates&nbsp;a&nbsp;Stream&nbsp;and&nbsp;uses&nbsp;autoboxing&nbsp;to&nbsp;put&nbsp;the&nbsp;Integer&nbsp;1&nbsp;inside.&nbsp;Line&nbsp;5&nbsp;converts&nbsp;to&nbsp;a&nbsp;primitive,&nbsp;again&nbsp;using&nbsp;autoboxing.&nbsp;Line&nbsp;6&nbsp;converts&nbsp;to&nbsp;a&nbsp;double&nbsp;primitive,&nbsp;which&nbsp;works&nbsp;since&nbsp;double&nbsp;d&nbsp;=&nbsp;1;&nbsp;would&nbsp;work.&nbsp;Line&nbsp;7&nbsp;is&nbsp;where&nbsp;it&nbsp;all&nbsp;falls&nbsp;apart.&nbsp;Converting&nbsp;from&nbsp;a&nbsp;double&nbsp;to&nbsp;an&nbsp;int&nbsp;would&nbsp;require&nbsp;a&nbsp;cast&nbsp;inside&nbsp;the&nbsp;lambda.$4
614$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;can&nbsp;legally&nbsp;fill&nbsp;in&nbsp;the&nbsp;blank?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br/><br/>public&nbsp;class&nbsp;AhChoo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;SneezeException&nbsp;extends&nbsp;Exception&nbsp;{&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;SniffleException&nbsp;extends&nbsp;SneezeException&nbsp;{&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;SneezeException&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SneezeException();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(SneezeException&nbsp;|&nbsp;SniffleException&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_________________<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br/>}$F.&nbsp;A&nbsp;multi-catch&nbsp;cannot&nbsp;catch&nbsp;both&nbsp;a&nbsp;superclass&nbsp;and&nbsp;subclass.&nbsp;Notice&nbsp;how&nbsp;similar&nbsp;questions&nbsp;can&nbsp;be&nbsp;while&nbsp;testing&nbsp;something&nbsp;that&nbsp;is&nbsp;entirely&nbsp;different.$6
714$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;calling&nbsp;the&nbsp;following&nbsp;method?<br/><br/>3:&nbsp;public&nbsp;void&nbsp;addAndPrintItems(BlockingDeque&lt;Integer&gt;&nbsp;deque)&nbsp;{<br/>4:&nbsp;deque.offer(103);<br/>5:&nbsp;deque.offerFirst(20,&nbsp;1,&nbsp;TimeUnit.SECONDS);<br/>6:&nbsp;deque.offerLast(85,&nbsp;7,&nbsp;TimeUnit.HOURS);<br/>7:&nbsp;System.out.print(deque.pollFirst(200,&nbsp;TimeUnit.NANOSECONDS));<br/>8:&nbsp;System.out.print(&quot;&nbsp;&quot;+deque.pollLast(1,&nbsp;TimeUnit.MINUTES));<br/>9:&nbsp;}<br/>$D.&nbsp;The&nbsp;methods&nbsp;on&nbsp;line&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;and&nbsp;8&nbsp;each&nbsp;throw&nbsp;InterruptedException,&nbsp;which&nbsp;is&nbsp;a&nbsp;checked&nbsp;exception;&nbsp;therefore&nbsp;the&nbsp;method&nbsp;does&nbsp;not&nbsp;compile&nbsp;and&nbsp;C&nbsp;is&nbsp;the&nbsp;only&nbsp;correct&nbsp;answer.&nbsp;If&nbsp;the&nbsp;method&nbsp;signature&nbsp;was&nbsp;updated&nbsp;to&nbsp;include&nbsp;throws&nbsp;InterruptedException,&nbsp;then&nbsp;the&nbsp;answer&nbsp;would&nbsp;be&nbsp;F,&nbsp;because&nbsp;the&nbsp;deque&nbsp;may&nbsp;be&nbsp;blocked&nbsp;at&nbsp;runtime&nbsp;when&nbsp;the&nbsp;offerFirst(),&nbsp;offerLast(),&nbsp;pollFirst(),&nbsp;and&nbsp;pollLast()&nbsp;operations&nbsp;are&nbsp;called.&nbsp;Finally,&nbsp;if&nbsp;they&nbsp;were&nbsp;not&nbsp;blocked&nbsp;and&nbsp;there&nbsp;were&nbsp;no&nbsp;other&nbsp;operations&nbsp;on&nbsp;the&nbsp;deque,&nbsp;then&nbsp;the&nbsp;output&nbsp;would&nbsp;be&nbsp;20&nbsp;85,&nbsp;and&nbsp;the&nbsp;answer&nbsp;would&nbsp;be&nbsp;A.$7
113$public&nbsp;class&nbsp;IsItFurry&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;interface&nbsp;Mammal&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Furry&nbsp;implements&nbsp;Mammal&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Chipmunk&nbsp;extends&nbsp;Furry&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chipmunk&nbsp;c&nbsp;=&nbsp;new&nbsp;Chipmunk();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mammal&nbsp;m&nbsp;=&nbsp;c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Furry&nbsp;f&nbsp;=&nbsp;c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;instanceof&nbsp;Mammal)&nbsp;result&nbsp;+=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;instanceof&nbsp;Furry)&nbsp;result&nbsp;+=&nbsp;2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(null&nbsp;instanceof&nbsp;Chipmunk)&nbsp;result&nbsp;+=&nbsp;4;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>}$B.&nbsp;c&nbsp;is&nbsp;an&nbsp;instance&nbsp;of&nbsp;Chipmunk.&nbsp;It&nbsp;is&nbsp;an&nbsp;instance&nbsp;of&nbsp;any&nbsp;superclasses&nbsp;or&nbsp;interfaces&nbsp;it&nbsp;implements.In&nbsp;this&nbsp;case,&nbsp;those&nbsp;are&nbsp;Furry,&nbsp;Mammal,&nbsp;and&nbsp;Object.&nbsp;null&nbsp;is&nbsp;not&nbsp;an&nbsp;instance&nbsp;of&nbsp;any&nbsp;type.&nbsp;Therefore,&nbsp;the&nbsp;first&nbsp;two&nbsp;if&nbsp;statements&nbsp;execute&nbsp;and&nbsp;result&nbsp;is&nbsp;3.$1
213$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;are&nbsp;properties&nbsp;of&nbsp;classes&nbsp;that&nbsp;define&nbsp;immutable&nbsp;objects?&nbsp;(Choose&nbsp;all<br>that&nbsp;apply.)$B,&nbsp;C,&nbsp;E.&nbsp;Immutable&nbsp;objects&nbsp;may&nbsp;not&nbsp;be&nbsp;modified&nbsp;after&nbsp;creation.&nbsp;B,&nbsp;C,&nbsp;and&nbsp;E&nbsp;are&nbsp;correct&nbsp;statements&nbsp;that&nbsp;support&nbsp;this&nbsp;property.&nbsp;A&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;immutable&nbsp;objects&nbsp;may&nbsp;have&nbsp;getter&nbsp;methods,&nbsp;just&nbsp;not&nbsp;setter&nbsp;methods.&nbsp;D&nbsp;is&nbsp;incorrect,&nbsp;as&nbsp;static&nbsp;methods&nbsp;are&nbsp;not&nbsp;part&nbsp;of&nbsp;the&nbsp;immutable&nbsp;object&nbsp;pattern.&nbsp;F&nbsp;is&nbsp;also&nbsp;incorrect,&nbsp;as&nbsp;the&nbsp;getter&nbsp;methods&nbsp;are&nbsp;not&nbsp;required&nbsp;to&nbsp;be&nbsp;marked&nbsp;synchronized.$2
313$Which&nbsp;of&nbsp;these&nbsp;statements&nbsp;can&nbsp;fill&nbsp;in&nbsp;the&nbsp;blank&nbsp;so&nbsp;that&nbsp;the&nbsp;Wildcard&nbsp;class&nbsp;compiles<br>successfully?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br>import&nbsp;java.util.*;<br>public&nbsp;class&nbsp;Wildcard&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;showSize(List&lt;?&gt;&nbsp;list)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(list.size());<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wildcard&nbsp;card&nbsp;=&nbsp;new&nbsp;Wildcard();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____________________________________<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;card.showSize(list);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;}$B,&nbsp;E.&nbsp;showSize()&nbsp;can&nbsp;take&nbsp;any&nbsp;type&nbsp;of&nbsp;List&nbsp;since&nbsp;it&nbsp;uses&nbsp;an&nbsp;unbounded&nbsp;wildcard.&nbsp;Option&nbsp;A&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;it&nbsp;is&nbsp;a&nbsp;Queue&nbsp;and&nbsp;not&nbsp;a&nbsp;List.&nbsp;Option&nbsp;C&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;the&nbsp;wildcard&nbsp;is&nbsp;not&nbsp;allowed&nbsp;to&nbsp;be&nbsp;on&nbsp;the&nbsp;right&nbsp;side&nbsp;of&nbsp;an&nbsp;assignment.&nbsp;Option&nbsp;D&nbsp;is&nbsp;incorrect&nbsp;because&nbsp;the&nbsp;generic&nbsp;types&nbsp;are&nbsp;not&nbsp;compatible.&nbsp;Option&nbsp;B&nbsp;is&nbsp;correct&nbsp;because&nbsp;a&nbsp;lower-bounded&nbsp;wildcard&nbsp;allows&nbsp;that&nbsp;same&nbsp;type&nbsp;to&nbsp;be&nbsp;the&nbsp;generic.&nbsp;Option&nbsp;E&nbsp;is&nbsp;correct&nbsp;because&nbsp;Integer&nbsp;is&nbsp;a&nbsp;subclass&nbsp;of&nbsp;Number.&nbsp;Vector&nbsp;is&nbsp;an&nbsp;old&nbsp;type&nbsp;of&nbsp;List.&nbsp;It&nbsp;isn’t&nbsp;common&nbsp;in&nbsp;new&nbsp;code,&nbsp;but&nbsp;you&nbsp;still&nbsp;need&nbsp;to&nbsp;know&nbsp;it&nbsp;for&nbsp;the&nbsp;exam&nbsp;and&nbsp;in&nbsp;case&nbsp;you&nbsp;encounter&nbsp;old&nbsp;code.$3
413$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;is&nbsp;true?<br>List&lt;Integer&gt;&nbsp;l1&nbsp;=&nbsp;Arrays.asList(1,&nbsp;2,&nbsp;3);<br>List&lt;Integer&gt;&nbsp;l2&nbsp;=&nbsp;Arrays.asList(4,&nbsp;5,&nbsp;6);<br>List&lt;Integer&gt;&nbsp;l3&nbsp;=&nbsp;Arrays.asList();<br>Stream.of(l1,&nbsp;l2,&nbsp;l3).map(x&nbsp;-&gt;&nbsp;x&nbsp;+&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;.flatMap(x&nbsp;-&gt;&nbsp;x.stream()).forEach(System.out::print);$F.&nbsp;If&nbsp;the&nbsp;map()&nbsp;and&nbsp;flatMap()&nbsp;calls&nbsp;were&nbsp;reversed,&nbsp;choice&nbsp;B&nbsp;would&nbsp;be&nbsp;correct.&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;Stream&nbsp;created&nbsp;from&nbsp;the&nbsp;source&nbsp;is&nbsp;of&nbsp;type&nbsp;Stream&lt;List&lt;Integer&gt;&gt;.&nbsp;The&nbsp;Function&nbsp;in&nbsp;map&nbsp;expects&nbsp;an&nbsp;Integer&nbsp;rather&nbsp;than&nbsp;a&nbsp;List&lt;Integer&gt;,&nbsp;so&nbsp;the&nbsp;code&nbsp;does&nbsp;not&nbsp;compile.$4
613$Which&nbsp;of&nbsp;the&nbsp;following&nbsp;can&nbsp;legally&nbsp;fill&nbsp;in&nbsp;the&nbsp;blank?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br>public&nbsp;class&nbsp;AhChoo&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;SneezeException&nbsp;extends&nbsp;Exception&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;SniffleException&nbsp;extends&nbsp;SneezeException&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;SneezeException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SneezeException();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(SneezeException&nbsp;|&nbsp;RuntimeException&nbsp;e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_________________<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}$A.&nbsp;Since&nbsp;a&nbsp;multi-catch&nbsp;is&nbsp;used,&nbsp;the&nbsp;variable&nbsp;in&nbsp;the&nbsp;catch&nbsp;block&nbsp;is&nbsp;effectively&nbsp;final&nbsp;and&nbsp;cannot&nbsp;be&nbsp;reassigned.$6
713$What&nbsp;statements&nbsp;about&nbsp;the&nbsp;following&nbsp;code&nbsp;snippet&nbsp;are&nbsp;true?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br>4:&nbsp;Stream&lt;String&gt;&nbsp;cats&nbsp;=&nbsp;Stream.of(&quot;leopard&quot;,&quot;lynx&quot;,&quot;ocelot&quot;,&quot;puma&quot;).parallel();<br>5:&nbsp;Stream&lt;String&gt;&nbsp;bears&nbsp;=&nbsp;Stream.of(&quot;panda&quot;,&quot;grizzly&quot;,&quot;polar&quot;).parallel();<br>6:&nbsp;ConcurrentMap&lt;Boolean,&nbsp;List&lt;String&gt;&gt;&nbsp;data&nbsp;=&nbsp;Stream.of(cats,bears)<br>7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.flatMap(s&nbsp;-&gt;&nbsp;s)<br>8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.groupingByConcurrent(s&nbsp;-&gt;&nbsp;!s.startsWith(&quot;p&quot;)));<br>9:&nbsp;System.out.println(data.get(false).size()+&quot;&nbsp;&quot;+data.get(true).size());$A,&nbsp;G.&nbsp;The&nbsp;code&nbsp;compiles&nbsp;and&nbsp;runs&nbsp;without&nbsp;issue,&nbsp;so&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;and&nbsp;F&nbsp;are&nbsp;incorrect.&nbsp;The&nbsp;collect()&nbsp;operation&nbsp;groups&nbsp;the&nbsp;animals&nbsp;into&nbsp;those&nbsp;that&nbsp;do&nbsp;and&nbsp;do&nbsp;not&nbsp;start&nbsp;with&nbsp;the&nbsp;letter&nbsp;p.&nbsp;Note&nbsp;that&nbsp;there&nbsp;are&nbsp;four&nbsp;animals&nbsp;that&nbsp;do&nbsp;not&nbsp;start&nbsp;with&nbsp;the&nbsp;letter&nbsp;p&nbsp;and&nbsp;three&nbsp;animals&nbsp;that&nbsp;do.&nbsp;The&nbsp;negation&nbsp;operator&nbsp;!&nbsp;before&nbsp;the&nbsp;startsWith()&nbsp;method&nbsp;means&nbsp;that&nbsp;results&nbsp;are&nbsp;reversed,&nbsp;so&nbsp;the&nbsp;output&nbsp;is&nbsp;3&nbsp;4&nbsp;and&nbsp;A&nbsp;is&nbsp;correct,&nbsp;making&nbsp;B&nbsp;incorrect.&nbsp;Finally,&nbsp;the&nbsp;stream&nbsp;created&nbsp;by&nbsp;flatMap()&nbsp;is&nbsp;a&nbsp;new&nbsp;stream&nbsp;that&nbsp;is&nbsp;not&nbsp;parallel&nbsp;by&nbsp;default,&nbsp;even&nbsp;though&nbsp;its&nbsp;elements&nbsp;are&nbsp;parallel&nbsp;streams.&nbsp;Therefore,&nbsp;the&nbsp;performance&nbsp;will&nbsp;be&nbsp;single-threaded&nbsp;and&nbsp;G&nbsp;is&nbsp;correct.$7
112$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following&nbsp;code?<br>public&nbsp;class&nbsp;Browsers&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Browser&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;go()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Inside&nbsp;Browser&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Firefox&nbsp;extends&nbsp;Browser&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;go()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Inside&nbsp;Firefox&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;IE&nbsp;extends&nbsp;Browser&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;go()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Inside&nbsp;IE&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Browser&nbsp;b&nbsp;=&nbsp;new&nbsp;Firefox();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IE&nbsp;e&nbsp;=&nbsp;(IE)&nbsp;b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.go();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>$E.&nbsp;The&nbsp;main&nbsp;method&nbsp;tries&nbsp;to&nbsp;cast&nbsp;a&nbsp;Firefox&nbsp;instance&nbsp;to&nbsp;IE.&nbsp;Since&nbsp;IE&nbsp;is&nbsp;not&nbsp;a&nbsp;subclass&nbsp;of&nbsp;Firefox,&nbsp;this&nbsp;throws&nbsp;a&nbsp;ClassCastException.$1
212$public&nbsp;interface&nbsp;Climb&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;isTooHigh(int&nbsp;height,&nbsp;int&nbsp;limit);<br>}<br>public&nbsp;class&nbsp;Climber&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check((h,&nbsp;l)&nbsp;-&gt;&nbsp;h.toString(),&nbsp;5);&nbsp;//&nbsp;x1<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;void&nbsp;check(Climb&nbsp;climb,&nbsp;int&nbsp;height)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(climb.isTooHigh(height,&nbsp;10))&nbsp;//&nbsp;x2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;too&nbsp;high&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;System.out.println(&quot;ok&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>}$C.&nbsp;The&nbsp;functional&nbsp;interface&nbsp;takes&nbsp;two&nbsp;int&nbsp;parameters.&nbsp;The&nbsp;code&nbsp;on&nbsp;line&nbsp;x1&nbsp;attempts&nbsp;to&nbsp;use&nbsp;them&nbsp;as&nbsp;if&nbsp;one&nbsp;is&nbsp;an&nbsp;Object,&nbsp;resulting&nbsp;in&nbsp;a&nbsp;compiler&nbsp;error&nbsp;making&nbsp;C&nbsp;the&nbsp;correct&nbsp;answer.&nbsp;It&nbsp;also&nbsp;tries&nbsp;to&nbsp;return&nbsp;String&nbsp;even&nbsp;though&nbsp;the&nbsp;data&nbsp;type&nbsp;for&nbsp;the&nbsp;functional&nbsp;interface&nbsp;method&nbsp;is&nbsp;&nbsp;boolean.&nbsp;It&nbsp;is&nbsp;tricky&nbsp;to&nbsp;use&nbsp;types&nbsp;in&nbsp;a&nbsp;lambda&nbsp;when&nbsp;they&nbsp;are&nbsp;implicitly&nbsp;specified.&nbsp;Remember&nbsp;to&nbsp;check&nbsp;the&nbsp;interface&nbsp;for&nbsp;the&nbsp;real&nbsp;type.$2
312$Which&nbsp;of&nbsp;these&nbsp;statements&nbsp;can&nbsp;fill&nbsp;in&nbsp;the&nbsp;blank&nbsp;so&nbsp;that&nbsp;the&nbsp;Helper&nbsp;class&nbsp;compiles&nbsp;successfully?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br>3:&nbsp;public&nbsp;class&nbsp;Helper&nbsp;{<br>4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;U&nbsp;extends&nbsp;Exception&gt;&nbsp;void&nbsp;printException(U&nbsp;u)&nbsp;{<br>5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(u.getMessage());<br>6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__________________________________<br>9:&nbsp;}&nbsp;<br>}$A,&nbsp;B,&nbsp;D.&nbsp;The&nbsp;generic&nbsp;type&nbsp;must&nbsp;be&nbsp;Exception&nbsp;or&nbsp;a&nbsp;subclass&nbsp;of&nbsp;Exception&nbsp;since&nbsp;this&nbsp;is&nbsp;an&nbsp;upper&nbsp;bound.&nbsp;C&nbsp;and&nbsp;E&nbsp;are&nbsp;wrong&nbsp;because&nbsp;Throwable&nbsp;is&nbsp;a&nbsp;superclass&nbsp;of&nbsp;Exception.&nbsp;D&nbsp;uses&nbsp;an&nbsp;odd&nbsp;syntax&nbsp;by&nbsp;explicitly&nbsp;listing&nbsp;the&nbsp;type,&nbsp;but&nbsp;you&nbsp;should&nbsp;be&nbsp;able&nbsp;to&nbsp;recognize&nbsp;it&nbsp;as&nbsp;acceptable.$3
412$Which&nbsp;functional&nbsp;interfaces&nbsp;complete&nbsp;the&nbsp;following&nbsp;code?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br>6:&nbsp;____________&nbsp;x&nbsp;=&nbsp;String::new;<br>7:&nbsp;____________&nbsp;y&nbsp;=&nbsp;(a,&nbsp;b)&nbsp;-&gt;&nbsp;System.out.println();<br>8:&nbsp;____________&nbsp;z&nbsp;=&nbsp;a&nbsp;-&gt;&nbsp;a&nbsp;+&nbsp;a;$A,&nbsp;F,&nbsp;G.&nbsp;Line&nbsp;6&nbsp;doesn&rsquo;t&nbsp;take&nbsp;any&nbsp;parameters,&nbsp;and&nbsp;it&nbsp;returns&nbsp;a&nbsp;String,&nbsp;making&nbsp;it&nbsp;a&nbsp;Supplier.&nbsp;Another&nbsp;clue&nbsp;is&nbsp;that&nbsp;it&nbsp;uses&nbsp;a&nbsp;constructor&nbsp;reference,&nbsp;which&nbsp;should&nbsp;scream&nbsp;Supplier!&nbsp;This&nbsp;makes&nbsp;choice&nbsp;F&nbsp;correct.&nbsp;Line&nbsp;7&nbsp;takes&nbsp;two&nbsp;parameters,&nbsp;and&nbsp;it&nbsp;doesn&rsquo;t&nbsp;return&nbsp;anything&nbsp;making&nbsp;it&nbsp;a&nbsp;BiConsumer.&nbsp;The&nbsp;print&nbsp;statement&nbsp;should&nbsp;also&nbsp;be&nbsp;a&nbsp;clue&nbsp;that&nbsp;we&nbsp;are&nbsp;dealing&nbsp;with&nbsp;a&nbsp;Consumer&nbsp;or&nbsp;BiConsumer.&nbsp;This&nbsp;makes&nbsp;choice&nbsp;A&nbsp;correct.&nbsp;Choices&nbsp;C&nbsp;and&nbsp;D&nbsp;are&nbsp;there&nbsp;to&nbsp;mislead&nbsp;you;&nbsp;these&nbsp;interfaces&nbsp;don&rsquo;t&nbsp;actually&nbsp;exist.&nbsp;BinaryOperator&nbsp;spells&nbsp;out&nbsp;binary.&nbsp;The&nbsp;other&nbsp;functional&nbsp;interfaces&nbsp;use&nbsp;the&nbsp;prefix&nbsp;Bi.&nbsp;Finally,&nbsp;line&nbsp;8&nbsp;takes&nbsp;a&nbsp;single&nbsp;parameter,&nbsp;and&nbsp;it&nbsp;returns&nbsp;the&nbsp;same&nbsp;type,&nbsp;which&nbsp;is&nbsp;a&nbsp;UnaryOperator.&nbsp;Since&nbsp;the&nbsp;types&nbsp;are&nbsp;the&nbsp;same,&nbsp;only&nbsp;one&nbsp;generic&nbsp;is&nbsp;needed,&nbsp;making&nbsp;choice&nbsp;G&nbsp;correct.$4
612$public&nbsp;class&nbsp;AhChoo&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;SneezeException&nbsp;extends&nbsp;Exception&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;SniffleException&nbsp;extends&nbsp;SneezeException&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;SneezeException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SneezeException();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(SneezeException&nbsp;e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>}$A,&nbsp;D,&nbsp;E.&nbsp;Since&nbsp;a&nbsp;single&nbsp;exception&nbsp;type&nbsp;is&nbsp;caught,&nbsp;only&nbsp;the&nbsp;same&nbsp;type&nbsp;of&nbsp;exception&nbsp;or&nbsp;a&nbsp;subclass&nbsp;is&nbsp;allowed&nbsp;to&nbsp;be&nbsp;assigned&nbsp;to&nbsp;the&nbsp;variable&nbsp;in&nbsp;the&nbsp;catch&nbsp;block.&nbsp;Therefore&nbsp;D&nbsp;and&nbsp;E&nbsp;are&nbsp;correct.&nbsp;Additionally&nbsp;A&nbsp;is&nbsp;correct&nbsp;because&nbsp;there&nbsp;are&nbsp;no&nbsp;changes&nbsp;to&nbsp;the&nbsp;variable.$6
712$What&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;executing&nbsp;the&nbsp;following&nbsp;application?&nbsp;(Choose&nbsp;all&nbsp;that&nbsp;apply.)<br>import&nbsp;java.util.concurrent.*;<br>public&nbsp;class&nbsp;CountNumbers&nbsp;extends&nbsp;RecursiveAction&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;end;<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;CountNumbers(int&nbsp;start,&nbsp;int&nbsp;end)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.start&nbsp;=&nbsp;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.end&nbsp;=&nbsp;end;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;compute()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&lt;0)&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;middle&nbsp;=&nbsp;start&nbsp;+&nbsp;((end&mdash;start)&nbsp;/&nbsp;2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invokeAll(new&nbsp;CountNumbers(start,&nbsp;middle),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;CountNumbers(middle,&nbsp;end));&nbsp;//&nbsp;m1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ForkJoinTask&lt;?&gt;&nbsp;task&nbsp;=&nbsp;new&nbsp;CountNumbers(0,&nbsp;4);&nbsp;//&nbsp;m2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ForkJoinPool&nbsp;pool&nbsp;=&nbsp;new&nbsp;ForkJoinPool();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;result&nbsp;=&nbsp;pool.invoke(task);&nbsp;//&nbsp;m3<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}$E.&nbsp;The&nbsp;program&nbsp;compiles&nbsp;without&nbsp;issue,&nbsp;so&nbsp;B,&nbsp;C,&nbsp;and&nbsp;D&nbsp;are&nbsp;incorrect.&nbsp;Lines&nbsp;m2&nbsp;and&nbsp;m3&nbsp;throw&nbsp;a&nbsp;compiler&nbsp;warning&nbsp;about&nbsp;generics&nbsp;but&nbsp;still&nbsp;compile.&nbsp;Notice&nbsp;that&nbsp;RecursiveAction,&nbsp;unlike&nbsp;RecursiveTask,&nbsp;does&nbsp;not&nbsp;return&nbsp;a&nbsp;value.&nbsp;However,&nbsp;since&nbsp;we&nbsp;used&nbsp;a&nbsp;generic&nbsp;Fork-&nbsp;JoinTask&nbsp;reference,&nbsp;the&nbsp;code&nbsp;still&nbsp;compiles.&nbsp;The&nbsp;issue&nbsp;here&nbsp;is&nbsp;that&nbsp;the&nbsp;base&nbsp;condition&nbsp;is&nbsp;not&nbsp;reached&nbsp;since&nbsp;the&nbsp;numbers&nbsp;start/end&nbsp;are&nbsp;consistently&nbsp;positive.&nbsp;This&nbsp;causes&nbsp;an&nbsp;infinite&nbsp;loop,&nbsp;although&nbsp;since&nbsp;memory&nbsp;is&nbsp;finite,&nbsp;Java&nbsp;detects&nbsp;this&nbsp;and&nbsp;throws&nbsp;a&nbsp;StackOverflowError,&nbsp;so&nbsp;E&nbsp;is&nbsp;correct.&nbsp;In&nbsp;practice,&nbsp;this&nbsp;could&nbsp;also&nbsp;generate&nbsp;a&nbsp;locking&nbsp;exception&nbsp;before&nbsp;the&nbsp;StackOverflowError&nbsp;when&nbsp;the&nbsp;program&nbsp;runs&nbsp;out&nbsp;of&nbsp;memory,&nbsp;but&nbsp;in&nbsp;either&nbsp;circumstance,&nbsp;the&nbsp;program&nbsp;will&nbsp;exit.$7
111$Which of the following statements can be inserted to make FootballGame compile?<br>package my.sports;<br><br>public class Football {<br>&nbsp;&nbsp;&nbsp;&nbsp;public static final int TEAM_SIZE = 11;<br>}<br><br>package my.apps;<br>// INSERT CODE HERE<br>public class FootballGame {<br>&nbsp;&nbsp;&nbsp;&nbsp;public int getTeamSize() { return TEAM_SIZE; }<br>}$D. FootballGame is trying to refer to a static variable in another class. It needs a static import to do so. The correct syntax is import static and not static import. B is incorrect because * does not import classes in a package. C is incorrect because it does not refer to a static member.$1
211$Which lambda can replace the MySecret class to return the same value? (Choose all that apply.)<br>public interface Secret {<br>&nbsp;&nbsp;&nbsp;&nbsp;String magic(double d);<br>}<br>public class MySecret implements Secret {<br>&nbsp;&nbsp;&nbsp;&nbsp;public String magic(double d) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &quot;Poof&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}$A, F. B is incorrect because it does not use the return keyword. C, D, and E are incorrect<br>because the variable e is already in use from the lambda and cannot be redefined. Additionally,<br>C is missing the return keyword and E is missing the semicolon. A and F are the only<br>correct lambda expressions that match the functional interface.$2
311$What is the result of the following code?<br>3: Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(10);<br>4: for (int i = 1; i &lt;= 10; i++) {<br>5: &nbsp;&nbsp;&nbsp;&nbsp;map.put(i, i * i);<br>6: }<br>7: System.out.println(map.get(4));$A. Line 3 uses the diamond operator to create the map. Lines 5 and 7 use autoboxing to<br>convert between the int primitive and the Integer wrapper class. The keys map to their<br>squared value. 1 maps to 1, 2 maps to 4, 3 maps to 9, 4 maps to 16, and so on.$3
411$What changes need to be made for this code to print the string 12345? (Choose all that apply.)<br>Stream.iterate(1, x -&gt; x++).limit(5).map(x -&gt; x).collect(Collectors.<br>joining());$B, C, E. As written, the code doesn&rsquo;t compile because the collector expects to get a String<br>immediately before it in the chain. Option B fixes this, at which point nothing is output<br>because the collector creates a String. Option E fixes this and causes the output to be<br>11111. Since the post-increment operator is used, the stream contains an infinite number of<br>1s. Option C fixes this and causes the stream to contain increasing numbers.$4
611$Which of the following are runtime exceptions? (Choose all that apply.)$B, D, E. You need to memorize the contents of Table 6.2 and Table 6.3 before the exam.$6
711$What statements about the following code snippet are true? (Choose all that apply.)<br>Object o1 = new Object();<br>Object o2 = new Object();<br>ExecutorService service = Executors.newFixedThreadPool(2);<br>Future&lt;?&gt; f1 = service.submit(() -&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;synchronized (o1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (o2) { System.out.println(&quot;Tortoise&quot;); } // t1<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>Future&lt;?&gt; f2 = service.submit(() -&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;synchronized (o2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (o1) { System.out.println(&quot;Hare&quot;); } // t2<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>f1.get();<br>f2.get();$A, F. The code compiles without issue, so D and E are incorrect. Since both tasks are submitted to the same thread executor pool, the order cannot be determined, so B and C are incorrect and A is correct. The key here is that the way the resources o1 and o2 are synchronized, a deadlock could appear if the first thread gets o1 and the second thread gets o2;therefore F is correct. The code cannot produce a livelock, since both threads are waiting, so G is incorrect. Finally, if a deadlock does occur, an exception will not be thrown, so H is incorrect.$7
103$What is the result of the following code?<br>String s1 = &quot;Canada&quot;;<br>String s2 = new String(s1);<br>if(s1 == s2) System.out.println(&quot;s1 == s2&quot;);<br>if(s1.equals(s2)) System.out.println(&quot;s1.equals(s2)&quot;);$C. s1 points to the string pool. s2 points to an object on the heap, since it is created<br>at runtime. == checks for reference equality. These are different references, making<br>B incorrect. String overrides equals() so the actual values are the same, making C<br>correct. And yes, this question could have appeared on the OCA. Remember that the<br>OCP is cumulative. A question may appear to be about one thing and actually be about a<br>simpler concept.$1
104$What is true about the following code? You may assume city and mascot are never null.<br>public class BaseballTeam {<br>&nbsp;&nbsp;&nbsp;&nbsp;private String city, mascot;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int numberOfPlayers;<br>&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !(obj instanceof BaseballTeam))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BaseballTeam other = (BaseballTeam) obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (city.equals(other.city) &amp;&amp; mascot.equals(other.mascot));<br>}$C. The equals() method is correct. You are allowed to use any business logic that you<br>want in determining equality. The hashCode() method is not correct. It violates the rule<br>that two objects that return true for equals() must return the same hashCode(). It is also<br>a bad idea for the hash code to contain values that could change.$1
105$Which of the following statements are true, assuming a and b are String objects? (Choose<br>all that apply.)$A, D. The relevant rule is that two objects that return true for equals() objects must<br>return the same hash code. Therefore A is correct and B is incorrect. Two objects with the<br>same hash code may or may not be equal. This makes C incorrect and D correct. The fact<br>that two objects are not equal does not guarantee or preclude them from sharing a hash<br>code. Remember that hashCode() tells you which bucket to look in and equals() tells you<br>whether you have found an exact match.$1
106$public class FlavorsEnum {<br>&nbsp;&nbsp;&nbsp;&nbsp;enum Flavors {<br>&nbsp;&nbsp;&nbsp;&nbsp;VANILLA, CHOCOLATE, STRAWBERRY<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Flavors.CHOCOLATE.ordinal());<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}$B. The ordinal() method of an enum returns its corresponding int value. Like arrays,<br>enums are zero based. Remember that the index of an enum may change when you recompile<br>the code and should not be used for comparison.$1
107$What is the result of the following code? (Choose all that apply.)<br>public class IceCream {<br>&nbsp;&nbsp;&nbsp;&nbsp;enum Flavors {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VANILLA, CHOCOLATE, STRAWBERRY<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flavors f = Flavors.STRAWBERRY;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (f) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: System.out.println(&quot;vanilla&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: System.out.println(&quot;chocolate&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: System.out.println(&quot;strawberry&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: System.out.println(&quot;missing flavor&quot;);<br>} } }$E. A case statement on an enum data type must be the unqualified name of an enumeration<br>constant. For example, case VANILLA would be valid. You cannot use the ordinal equivalents.<br>Therefore, the code does not compile.$1
108$What is the result of the following code?<br>1: public class Outer {<br>2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int x = 5;<br>3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected class Inner {<br>4: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static int x = 10;<br>5: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void go() { System.out.println(x); }<br>6: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>7: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>8: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Outer out = new Outer();<br>9: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Outer.Inner in = out.new Inner();<br>10: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in.go();<br>11: } }$C. Inner is a member inner class. Inner classes are not allowed to contain static methods<br>or static variables. Only nested static classes are permitted to contain statics.$1
109$What is the result of the following code?<br>1: public class Outer {<br>2: &nbsp;&nbsp;&nbsp;&nbsp;private int x = 24;<br>3: &nbsp;&nbsp;&nbsp;&nbsp;public int getX() {<br>4: &nbsp;&nbsp;&nbsp;&nbsp;String message = &quot;x is &quot;;<br>5: &nbsp;&nbsp;&nbsp;&nbsp;class Inner {<br>6: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int x = Outer.this.x;<br>7: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void printX() {<br>8: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(message + x);<br>9: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>10: }<br>11: Inner in = new Inner();<br>12: in.printX();<br>13: return x;<br>14: }<br>15: public static void main(String[] args) {<br>16: &nbsp;&nbsp;&nbsp;&nbsp;new Outer().getX();<br>17: } }$B. Outer.this.x is the correct way to refer to x in the Outer class. In Java 7, the answer<br>would have been D because you used to have to declare variables as final to use them in a<br>local inner class. In Java 8, this requirement was dropped and the variables only need to be<br>effectively final, which means that the code would still compile if final were added.$1
110$The following code appears in a file named Book.java. What is the result of compiling the source file?<br>1: public class Book {<br>2: private int pageNumber;<br>3: private class BookReader {<br>4: public int getPage() {<br>5: return pageNumber;<br>6: } } }$C. The code compiles fine. A member inner class is allowed to be private, and it is<br>allowed to refer to instance variables from the outer class. Two .class files are generated.<br>Book.class matches the name of the outer class. The inner class does not compile<br>to BookReader.class. That would introduce the possibility of a naming conflict.<br>Book$BookReader.class is correct because it shows the scope of the class is limited to<br>Book. You don&rsquo;t need to know that $ is the syntax, but you do need to know the number of<br>classes and that BookReader is not a top-level class.$1
210$What is the result of the following code?<br>1: public interface CanWalk {<br>2: 	default void walk() { System.out.println(&quot;Walking&quot;); }<br>3: }<br>4: public interface CanRun {<br>5: 	public default void walk() { System.out.println(&quot;Walking&quot;); }<br>6:	public abstract void run();<br>7: }<br>8: public interface CanSprint extends CanWalk, CanRun {<br>9: 	void sprint();<br>10:}$D. While Java supports multiple inheritance through interfaces, it does not support method<br>overriding in interfaces, since it&rsquo;s not clear which parent method should be used. In this<br>example, CanWalk and CanRun both implement a default walk() method. The definition of<br>CanSprint extends these two interfaces and therefore won&rsquo;t compile as two default methods<br>with the same signature from parent classes are detected, therefore the answer is D. None<br>of the other lines of code cause problems, so the rest of the answers are not correct.$2
310$What is the result of the following program?<br>import java.util.*;<br>public class MyComparator implements Comparator&lt;String&gt; {<br>	public int compare(String a, String b) {<br>		return b.toLowerCase().compareTo(a.toLowerCase());<br>	}<br><br>	public static void main(String[] args) {<br>		String[] values = { &quot;123&quot;, &quot;Abb&quot;, &quot;aab&quot; };<br>		Arrays.sort(values, new MyComparator());<br>		for (String s: values)<br>			System.out.print(s + &quot; &quot;);<br>	}<br>}$A. The array is sorted using MyComparator, which sorts the elements in reverse alphabetical<br>order in a case-insensitive fashion. Normally, numbers sort before letters. This code<br>reverses that by calling the compareTo() method on b instead of a.$3
410$Select from the following statements and indicate the order in which they would appear to output 10 lines:<br>Stream.generate(() -&gt; &quot;1&quot;)<br>L: .filter(x -&gt; x.length() &gt; 1)<br>M: .forEach(System.out::println)<br>N: .limit(10)<br>O: .peek(System.out::println)<br>;$F. The terminal operation must be right before the semicolon, which is line M. Remember that forEach() is a terminal operation while peek() is an intermediate operation. This eliminates all but choices C, E, and F. Choice E is incorrect because there is no limit()<br>operation, which means that the code would run infinitely. Choice C is incorrect because<br>filter() is called before limit(). No elements make it through the filter, so the code also<br>runs infinitely. Choice F is correct.$4
610$Which of the following are true of the code? (Choose all that apply.)<br>4: private int addPlusOne(int a, int b) {<br>5: 	boolean assert = false;<br>6: 	assert a++ &gt; 0;<br>7: 	assert b &gt; 0;<br>8: 	return a + b;<br>9: }$A, E. Line 5 does not compile because assert is a reserved word making Choice A correct.B and C are incorrect because the parenthesis and message are both optional. D is incorrect because assertions should not have side effects. E is correct because checking an argument<br>passed from elsewhere in the program is an appropriate use of an assertion.$6
710$What statements about the following code are true? (Choose all that apply.)<br><br>System.out.println(Arrays.asList(&quot;duck&quot;,&quot;chicken&quot;,&quot;flamingo&quot;,&quot;pelican&quot;)<br>	.parallelStream().parallel() // q1<br>	.reduce(0,<br>		(c1, c2) -&gt; c1.length() + c2.length(), // q2<br>(		s1, s2) -&gt; s1 + s2)); // q3$C. The code does not compile, so A and E are incorrect. The problem here is that c1 is a String but c2 is an int, so the code fails to combine on line q2, since calling length() on an int is not allowed, and C is correct. The rest of the lines compile without issue. Note that calling parallel() on an already parallel is allowed, and it may in fact return the<br>same object.$7
201$Which of the following statements about design principles and design patterns are true?(Choose all that apply.)$C, E. Option A is incorrect as a design pattern is focused on solving a specific commonly occurring problem. Option B is also incorrect, as design principles and design patterns are different, despite both promoting better code development. Option D is incorrect as design patterns may be applied to static or non-static classes alike. Options C and E are correct statements about design principles and design patterns.$2
202$What is the result of the following code?<br>1: public interface CanClimb {<br>2: &nbsp;&nbsp;&nbsp;&nbsp;public abstract void climb();<br>3: }<br>4: public interface CanClimbTrees extends CanClimb {}<br>5: public abstract class Chipmunk implements CanClimbTrees {<br>6: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public abstract void chew();<br>7: }<br>8: public class EasternChipmunk extends Chipmunk {<br>9: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void chew() { System.out.println(&quot;Eastern Chipmunk is Chewing&quot;); }<br>10: }$E. The code does not compile because EasternChipmunk inherits the abstract method climb() but does not implement it, therefore the correct answer is E. B, C, and D are incorrect as they compile for various reasons. Line 2 compiles, as non-static and nondefault interface methods are assumed to have the abstract modifier. Line 4 compiles without issue as an interface can extend another interface. Line 5 compiles without issue as an abstract class can implement an interface without implementing any of the abstract methods. F is incorrect, as Line 8 does not compile.$2
203$Which of the following are valid functional interfaces? (Choose all that apply.)<br>public interface Climb {<br>&nbsp;&nbsp;&nbsp;&nbsp;public int climb();<br>}<br>public abstract class Swim {<br>&nbsp;&nbsp;&nbsp;&nbsp;public abstract Object swim(double speed, int duration);<br>}<br>public interface ArcticMountainClimb extends MountainClimb {<br>&nbsp;&nbsp;&nbsp;&nbsp;public default int getSpeed();<br>}<br>public interface MountainClimb extends Climb {}&nbsp;&nbsp;&nbsp;&nbsp;$A, D. A is correct as Climb defines an interface with exactly one abstract method. B is incorrect, as abstract classes are not functional interfaces despite having a single abstract method. While functional interfaces may have any number of default methods, Arctic- MountainClimb will not compile due to the default method getSpeed() missing an implementation body, so C is incorrect. D is correct, as the interface MountainClimb has exactly one abstract method defined in Climb. Finally, E is incorrect because A and D are correct.$2
204$Which of the following are valid lambda expressions? (Choose all that apply.)$A, D. The first lambda expression is valid, taking no arguments and returning the empty string, so A is correct. B is incorrect, as more than one parameter requires parentheses (). C is incorrect, as brackets {} are required when using return. D is correct, as the expression takes one Camel input and returns void. E is incorrect, as parentheses are required when using the data type Wolf. F is incorrect, as it has no right-side expression. Finally, G is incorrect, as specifying the data type for one parameter in a lambda expression requires you to specify the data type for all parameters in the expression. In this case, z has a data type and m does not, therefore the expression is invalid.$2
205$What are some of the properties of using the singleton pattern? (Choose all that apply.)$B, E, F. A is incorrect, as any method that changes the singleton breaks the singleton pattern. B is correct, as the constructor of the singleton class must be private, else other classes would be able to instantiate it, breaking the singleton pattern. C is incorrect, as the name of the object itself, as well as the method to retrieve the singleton, is not defined in the pattern. D is incorrect, as the object must be marked private. If it was marked protected, it would not be properly encapsulated and other classes would have access to it. E is correct, as the purpose of a singleton is to ensure that all threads share the same instance of the object in memory. F is correct, as a public static method is required for all threads to access the same singleton.$2
206$import java.util.function.*;<br>public class Panda {<br>&nbsp;&nbsp;&nbsp;&nbsp;int age;<br>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Panda p1 = new Panda();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1.age = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check(p1, p -&gt; p.age &lt; 5); // h1<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;private static void check(Panda panda, Predicate&lt;Panda&gt; pred) { // h2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = pred.test(panda) ? &quot;match&quot;: &quot;not match&quot;; // h3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(result);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}$A. This code compiles and runs without issue so C, D, E, and F are incorrect. Line h1 creates a lambda expression that checks if the age is less than 5. Since there is only one parameter and it does not specify a type, the parentheses around the type parameter are optional. Line h2 uses the Predicate interface, which declares a test() method. Since test() returns true on the expression, match is output and A is correct.$2
207$What changes need to be made to make the following immutable object pattern correct?<br>(Choose all that apply.)<br>import java.util.List;<br>public class Seal {<br>&nbsp;&nbsp;&nbsp;&nbsp;String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private final List&lt;Seal&gt; friends;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Seal(String name, List&lt;Seal&gt; friends) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.friends = friends;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String getName() { return name; }<br>&nbsp;&nbsp;&nbsp;&nbsp;public List&lt;Seal&gt; getFriends() { return friends; }<br>}$C, E, G, H. A is incorrect, as there are definitely some problems with the immutable objects implementation. B is incorrect, as there is no such thing as the Immutable interface defined in the Java API. C is correct, as all instance variables should be private and final to prevent them from being changed by a caller. D is incorrect, as adding settings is the opposite of what you do with the immutable object pattern. E is correct, since List&lt;Seal&gt; is mutable, all direct access should be removed. F is incorrect, as this has nothing to do with immutability. G is correct, as we need to copy the mutable List&lt;Seal&gt; to prevent the caller of the constructor from maintaining access to a mutable structure within our class. H is also correct, as it prevents the methods of the class from being overridden.$2
208$Which of the following are true of interfaces? (Choose all that apply.)$C, F. A and B are both incorrect as interfaces can extend other interfaces, although not classes. C is correct since a class may implement multiple interfaces. D is incorrect as interfaces have static and default methods, as well as static final variables. E is incorrect as interfaces are assumed to be abstract, and abstract and final can never be used together. F is correct as interface methods and variables are each assumed public.$2
209$What changes need to be made to make the following singleton pattern correct? (Choose all<br>that apply.)<br>public class CheetahManager {<br>&nbsp;&nbsp;&nbsp;&nbsp;public static CheetahManager cheetahManager;<br>&nbsp;&nbsp;&nbsp;&nbsp;private CheetahManager() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;public static CheetahManager getCheetahManager() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cheetahManager == null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cheetahManager = new CheetahManager();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return cheetahManager;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}$D, F. A is incorrect, as there are definitely some problems with the singleton implementation. B and C are incorrect, as naming of the instance variable and access method are not required as part of the pattern. The public modifier on the cheetahManager instance means that any class can access or even replace the instance, which breaks the singleton pattern; hence D is required to fix the implementation. E is incorrect, as marking the instance final would prevent lazy instantiation and as the code would not compile. F is also required, since without this step two threads could create two distinct instances of the singleton at the same time, which would violate the singleton pattern.$2
